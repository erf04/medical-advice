{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.map.get-or-insert.js\";\nimport \"core-js/modules/es.map.get-or-insert-computed.js\";\nimport \"core-js/modules/es.weak-map.get-or-insert.js\";\nimport \"core-js/modules/es.weak-map.get-or-insert-computed.js\";\nconst TYPE_REQUEST = \"q\";\nconst TYPE_RESPONSE = \"s\";\nconst DEFAULT_TIMEOUT = 6e4;\nfunction defaultSerialize(i) {\n  return i;\n}\nconst defaultDeserialize = defaultSerialize;\nconst {\n  clearTimeout,\n  setTimeout\n} = globalThis;\nconst random = Math.random.bind(Math);\nfunction createBirpc($functions, options) {\n  const {\n    post,\n    on,\n    off = () => {},\n    eventNames = [],\n    serialize = defaultSerialize,\n    deserialize = defaultDeserialize,\n    resolver,\n    bind = \"rpc\",\n    timeout = DEFAULT_TIMEOUT\n  } = options;\n  let $closed = false;\n  const _rpcPromiseMap = /* @__PURE__ */new Map();\n  let _promiseInit;\n  let rpc;\n  async function _call(method, args, event, optional) {\n    if ($closed) throw new Error(`[birpc] rpc is closed, cannot call \"${method}\"`);\n    const req = {\n      m: method,\n      a: args,\n      t: TYPE_REQUEST\n    };\n    if (optional) req.o = true;\n    const send = async _req => post(serialize(_req));\n    if (event) {\n      await send(req);\n      return;\n    }\n    if (_promiseInit) {\n      try {\n        await _promiseInit;\n      } finally {\n        _promiseInit = void 0;\n      }\n    }\n    let {\n      promise,\n      resolve,\n      reject\n    } = createPromiseWithResolvers();\n    const id = nanoid();\n    req.i = id;\n    let timeoutId;\n    async function handler(newReq = req) {\n      if (timeout >= 0) {\n        timeoutId = setTimeout(() => {\n          try {\n            const handleResult = options.onTimeoutError?.call(rpc, method, args);\n            if (handleResult !== true) throw new Error(`[birpc] timeout on calling \"${method}\"`);\n          } catch (e) {\n            reject(e);\n          }\n          _rpcPromiseMap.delete(id);\n        }, timeout);\n        if (typeof timeoutId === \"object\") timeoutId = timeoutId.unref?.();\n      }\n      _rpcPromiseMap.set(id, {\n        resolve,\n        reject,\n        timeoutId,\n        method\n      });\n      await send(newReq);\n      return promise;\n    }\n    try {\n      if (options.onRequest) await options.onRequest.call(rpc, req, handler, resolve);else await handler();\n    } catch (e) {\n      if (options.onGeneralError?.call(rpc, e) !== true) throw e;\n      return;\n    } finally {\n      clearTimeout(timeoutId);\n      _rpcPromiseMap.delete(id);\n    }\n    return promise;\n  }\n  const $call = (method, ...args) => _call(method, args, false);\n  const $callOptional = (method, ...args) => _call(method, args, false, true);\n  const $callEvent = (method, ...args) => _call(method, args, true);\n  const $callRaw = options2 => _call(options2.method, options2.args, options2.event, options2.optional);\n  const builtinMethods = {\n    $call,\n    $callOptional,\n    $callEvent,\n    $callRaw,\n    $rejectPendingCalls,\n    get $closed() {\n      return $closed;\n    },\n    get $meta() {\n      return options.meta;\n    },\n    $close,\n    $functions\n  };\n  rpc = new Proxy({}, {\n    get(_, method) {\n      if (Object.prototype.hasOwnProperty.call(builtinMethods, method)) return builtinMethods[method];\n      if (method === \"then\" && !eventNames.includes(\"then\") && !(\"then\" in $functions)) return void 0;\n      const sendEvent = (...args) => _call(method, args, true);\n      if (eventNames.includes(method)) {\n        sendEvent.asEvent = sendEvent;\n        return sendEvent;\n      }\n      const sendCall = (...args) => _call(method, args, false);\n      sendCall.asEvent = sendEvent;\n      return sendCall;\n    }\n  });\n  function $close(customError) {\n    $closed = true;\n    _rpcPromiseMap.forEach(({\n      reject,\n      method\n    }) => {\n      const error = new Error(`[birpc] rpc is closed, cannot call \"${method}\"`);\n      if (customError) {\n        customError.cause ??= error;\n        return reject(customError);\n      }\n      reject(error);\n    });\n    _rpcPromiseMap.clear();\n    off(onMessage);\n  }\n  function $rejectPendingCalls(handler) {\n    const entries = Array.from(_rpcPromiseMap.values());\n    const handlerResults = entries.map(({\n      method,\n      reject\n    }) => {\n      if (!handler) {\n        return reject(new Error(`[birpc]: rejected pending call \"${method}\".`));\n      }\n      return handler({\n        method,\n        reject\n      });\n    });\n    _rpcPromiseMap.clear();\n    return handlerResults;\n  }\n  async function onMessage(data, ...extra) {\n    let msg;\n    try {\n      msg = deserialize(data);\n    } catch (e) {\n      if (options.onGeneralError?.call(rpc, e) !== true) throw e;\n      return;\n    }\n    if (msg.t === TYPE_REQUEST) {\n      const {\n        m: method,\n        a: args,\n        o: optional\n      } = msg;\n      let result, error;\n      let fn = await (resolver ? resolver.call(rpc, method, $functions[method]) : $functions[method]);\n      if (optional) fn ||= () => void 0;\n      if (!fn) {\n        error = new Error(`[birpc] function \"${method}\" not found`);\n      } else {\n        try {\n          result = await fn.apply(bind === \"rpc\" ? rpc : $functions, args);\n        } catch (e) {\n          error = e;\n        }\n      }\n      if (msg.i) {\n        if (error && options.onError) options.onError.call(rpc, error, method, args);\n        if (error && options.onFunctionError) {\n          if (options.onFunctionError.call(rpc, error, method, args) === true) return;\n        }\n        if (!error) {\n          try {\n            await post(serialize({\n              t: TYPE_RESPONSE,\n              i: msg.i,\n              r: result\n            }), ...extra);\n            return;\n          } catch (e) {\n            error = e;\n            if (options.onGeneralError?.call(rpc, e, method, args) !== true) throw e;\n          }\n        }\n        try {\n          await post(serialize({\n            t: TYPE_RESPONSE,\n            i: msg.i,\n            e: error\n          }), ...extra);\n        } catch (e) {\n          if (options.onGeneralError?.call(rpc, e, method, args) !== true) throw e;\n        }\n      }\n    } else {\n      const {\n        i: ack,\n        r: result,\n        e: error\n      } = msg;\n      const promise = _rpcPromiseMap.get(ack);\n      if (promise) {\n        clearTimeout(promise.timeoutId);\n        if (error) promise.reject(error);else promise.resolve(result);\n      }\n      _rpcPromiseMap.delete(ack);\n    }\n  }\n  _promiseInit = on(onMessage);\n  return rpc;\n}\nconst cacheMap = /* @__PURE__ */new WeakMap();\nfunction cachedMap(items, fn) {\n  return items.map(i => {\n    let r = cacheMap.get(i);\n    if (!r) {\n      r = fn(i);\n      cacheMap.set(i, r);\n    }\n    return r;\n  });\n}\nfunction createBirpcGroup(functions, channels, options = {}) {\n  const getChannels = () => typeof channels === \"function\" ? channels() : channels;\n  const getClients = (channels2 = getChannels()) => cachedMap(channels2, s => createBirpc(functions, {\n    ...options,\n    ...s\n  }));\n  function _boardcast(method, args, event, optional) {\n    const clients = getClients();\n    return Promise.all(clients.map(c => c.$callRaw({\n      method,\n      args,\n      event,\n      optional\n    })));\n  }\n  function $call(method, ...args) {\n    return _boardcast(method, args, false);\n  }\n  function $callOptional(method, ...args) {\n    return _boardcast(method, args, false, true);\n  }\n  function $callEvent(method, ...args) {\n    return _boardcast(method, args, true);\n  }\n  const broadcastBuiltin = {\n    $call,\n    $callOptional,\n    $callEvent\n  };\n  const broadcastProxy = new Proxy({}, {\n    get(_, method) {\n      if (Object.prototype.hasOwnProperty.call(broadcastBuiltin, method)) return broadcastBuiltin[method];\n      const client = getClients();\n      const callbacks = client.map(c => c[method]);\n      const sendCall = (...args) => {\n        return Promise.all(callbacks.map(i => i(...args)));\n      };\n      sendCall.asEvent = async (...args) => {\n        await Promise.all(callbacks.map(i => i.asEvent(...args)));\n      };\n      return sendCall;\n    }\n  });\n  function updateChannels(fn) {\n    const channels2 = getChannels();\n    fn?.(channels2);\n    return getClients(channels2);\n  }\n  getClients();\n  return {\n    get clients() {\n      return getClients();\n    },\n    functions,\n    updateChannels,\n    broadcast: broadcastProxy,\n    /**\n     * @deprecated use `broadcast`\n     */\n    // @ts-expect-error deprecated\n    boardcast: broadcastProxy\n  };\n}\nfunction createPromiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\nconst urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction nanoid(size = 21) {\n  let id = \"\";\n  let i = size;\n  while (i--) id += urlAlphabet[random() * 64 | 0];\n  return id;\n}\nexport { DEFAULT_TIMEOUT, cachedMap, createBirpc, createBirpcGroup };","map":{"version":3,"names":["TYPE_REQUEST","TYPE_RESPONSE","DEFAULT_TIMEOUT","defaultSerialize","i","defaultDeserialize","clearTimeout","setTimeout","globalThis","random","Math","bind","createBirpc","$functions","options","post","on","off","eventNames","serialize","deserialize","resolver","timeout","$closed","_rpcPromiseMap","Map","_promiseInit","rpc","_call","method","args","event","optional","Error","req","m","a","t","o","send","_req","promise","resolve","reject","createPromiseWithResolvers","id","nanoid","timeoutId","handler","newReq","handleResult","onTimeoutError","call","e","delete","unref","set","onRequest","onGeneralError","$call","$callOptional","$callEvent","$callRaw","options2","builtinMethods","$rejectPendingCalls","$meta","meta","$close","Proxy","get","_","Object","prototype","hasOwnProperty","includes","sendEvent","asEvent","sendCall","customError","forEach","error","cause","clear","onMessage","entries","Array","from","values","handlerResults","map","data","extra","msg","result","fn","apply","onError","onFunctionError","r","ack","cacheMap","WeakMap","cachedMap","items","createBirpcGroup","functions","channels","getChannels","getClients","channels2","s","_boardcast","clients","Promise","all","c","broadcastBuiltin","broadcastProxy","client","callbacks","updateChannels","broadcast","boardcast","res","rej","urlAlphabet","size"],"sources":["F:/programming/medical-consultant/frontend/node_modules/birpc/dist/index.mjs"],"sourcesContent":["const TYPE_REQUEST = \"q\";\nconst TYPE_RESPONSE = \"s\";\nconst DEFAULT_TIMEOUT = 6e4;\nfunction defaultSerialize(i) {\n  return i;\n}\nconst defaultDeserialize = defaultSerialize;\nconst { clearTimeout, setTimeout } = globalThis;\nconst random = Math.random.bind(Math);\nfunction createBirpc($functions, options) {\n  const {\n    post,\n    on,\n    off = () => {\n    },\n    eventNames = [],\n    serialize = defaultSerialize,\n    deserialize = defaultDeserialize,\n    resolver,\n    bind = \"rpc\",\n    timeout = DEFAULT_TIMEOUT\n  } = options;\n  let $closed = false;\n  const _rpcPromiseMap = /* @__PURE__ */ new Map();\n  let _promiseInit;\n  let rpc;\n  async function _call(method, args, event, optional) {\n    if ($closed)\n      throw new Error(`[birpc] rpc is closed, cannot call \"${method}\"`);\n    const req = { m: method, a: args, t: TYPE_REQUEST };\n    if (optional)\n      req.o = true;\n    const send = async (_req) => post(serialize(_req));\n    if (event) {\n      await send(req);\n      return;\n    }\n    if (_promiseInit) {\n      try {\n        await _promiseInit;\n      } finally {\n        _promiseInit = void 0;\n      }\n    }\n    let { promise, resolve, reject } = createPromiseWithResolvers();\n    const id = nanoid();\n    req.i = id;\n    let timeoutId;\n    async function handler(newReq = req) {\n      if (timeout >= 0) {\n        timeoutId = setTimeout(() => {\n          try {\n            const handleResult = options.onTimeoutError?.call(rpc, method, args);\n            if (handleResult !== true)\n              throw new Error(`[birpc] timeout on calling \"${method}\"`);\n          } catch (e) {\n            reject(e);\n          }\n          _rpcPromiseMap.delete(id);\n        }, timeout);\n        if (typeof timeoutId === \"object\")\n          timeoutId = timeoutId.unref?.();\n      }\n      _rpcPromiseMap.set(id, { resolve, reject, timeoutId, method });\n      await send(newReq);\n      return promise;\n    }\n    try {\n      if (options.onRequest)\n        await options.onRequest.call(rpc, req, handler, resolve);\n      else\n        await handler();\n    } catch (e) {\n      if (options.onGeneralError?.call(rpc, e) !== true)\n        throw e;\n      return;\n    } finally {\n      clearTimeout(timeoutId);\n      _rpcPromiseMap.delete(id);\n    }\n    return promise;\n  }\n  const $call = (method, ...args) => _call(method, args, false);\n  const $callOptional = (method, ...args) => _call(method, args, false, true);\n  const $callEvent = (method, ...args) => _call(method, args, true);\n  const $callRaw = (options2) => _call(options2.method, options2.args, options2.event, options2.optional);\n  const builtinMethods = {\n    $call,\n    $callOptional,\n    $callEvent,\n    $callRaw,\n    $rejectPendingCalls,\n    get $closed() {\n      return $closed;\n    },\n    get $meta() {\n      return options.meta;\n    },\n    $close,\n    $functions\n  };\n  rpc = new Proxy({}, {\n    get(_, method) {\n      if (Object.prototype.hasOwnProperty.call(builtinMethods, method))\n        return builtinMethods[method];\n      if (method === \"then\" && !eventNames.includes(\"then\") && !(\"then\" in $functions))\n        return void 0;\n      const sendEvent = (...args) => _call(method, args, true);\n      if (eventNames.includes(method)) {\n        sendEvent.asEvent = sendEvent;\n        return sendEvent;\n      }\n      const sendCall = (...args) => _call(method, args, false);\n      sendCall.asEvent = sendEvent;\n      return sendCall;\n    }\n  });\n  function $close(customError) {\n    $closed = true;\n    _rpcPromiseMap.forEach(({ reject, method }) => {\n      const error = new Error(`[birpc] rpc is closed, cannot call \"${method}\"`);\n      if (customError) {\n        customError.cause ??= error;\n        return reject(customError);\n      }\n      reject(error);\n    });\n    _rpcPromiseMap.clear();\n    off(onMessage);\n  }\n  function $rejectPendingCalls(handler) {\n    const entries = Array.from(_rpcPromiseMap.values());\n    const handlerResults = entries.map(({ method, reject }) => {\n      if (!handler) {\n        return reject(new Error(`[birpc]: rejected pending call \"${method}\".`));\n      }\n      return handler({ method, reject });\n    });\n    _rpcPromiseMap.clear();\n    return handlerResults;\n  }\n  async function onMessage(data, ...extra) {\n    let msg;\n    try {\n      msg = deserialize(data);\n    } catch (e) {\n      if (options.onGeneralError?.call(rpc, e) !== true)\n        throw e;\n      return;\n    }\n    if (msg.t === TYPE_REQUEST) {\n      const { m: method, a: args, o: optional } = msg;\n      let result, error;\n      let fn = await (resolver ? resolver.call(rpc, method, $functions[method]) : $functions[method]);\n      if (optional)\n        fn ||= () => void 0;\n      if (!fn) {\n        error = new Error(`[birpc] function \"${method}\" not found`);\n      } else {\n        try {\n          result = await fn.apply(bind === \"rpc\" ? rpc : $functions, args);\n        } catch (e) {\n          error = e;\n        }\n      }\n      if (msg.i) {\n        if (error && options.onError)\n          options.onError.call(rpc, error, method, args);\n        if (error && options.onFunctionError) {\n          if (options.onFunctionError.call(rpc, error, method, args) === true)\n            return;\n        }\n        if (!error) {\n          try {\n            await post(serialize({ t: TYPE_RESPONSE, i: msg.i, r: result }), ...extra);\n            return;\n          } catch (e) {\n            error = e;\n            if (options.onGeneralError?.call(rpc, e, method, args) !== true)\n              throw e;\n          }\n        }\n        try {\n          await post(serialize({ t: TYPE_RESPONSE, i: msg.i, e: error }), ...extra);\n        } catch (e) {\n          if (options.onGeneralError?.call(rpc, e, method, args) !== true)\n            throw e;\n        }\n      }\n    } else {\n      const { i: ack, r: result, e: error } = msg;\n      const promise = _rpcPromiseMap.get(ack);\n      if (promise) {\n        clearTimeout(promise.timeoutId);\n        if (error)\n          promise.reject(error);\n        else\n          promise.resolve(result);\n      }\n      _rpcPromiseMap.delete(ack);\n    }\n  }\n  _promiseInit = on(onMessage);\n  return rpc;\n}\nconst cacheMap = /* @__PURE__ */ new WeakMap();\nfunction cachedMap(items, fn) {\n  return items.map((i) => {\n    let r = cacheMap.get(i);\n    if (!r) {\n      r = fn(i);\n      cacheMap.set(i, r);\n    }\n    return r;\n  });\n}\nfunction createBirpcGroup(functions, channels, options = {}) {\n  const getChannels = () => typeof channels === \"function\" ? channels() : channels;\n  const getClients = (channels2 = getChannels()) => cachedMap(channels2, (s) => createBirpc(functions, { ...options, ...s }));\n  function _boardcast(method, args, event, optional) {\n    const clients = getClients();\n    return Promise.all(clients.map((c) => c.$callRaw({ method, args, event, optional })));\n  }\n  function $call(method, ...args) {\n    return _boardcast(method, args, false);\n  }\n  function $callOptional(method, ...args) {\n    return _boardcast(method, args, false, true);\n  }\n  function $callEvent(method, ...args) {\n    return _boardcast(method, args, true);\n  }\n  const broadcastBuiltin = {\n    $call,\n    $callOptional,\n    $callEvent\n  };\n  const broadcastProxy = new Proxy({}, {\n    get(_, method) {\n      if (Object.prototype.hasOwnProperty.call(broadcastBuiltin, method))\n        return broadcastBuiltin[method];\n      const client = getClients();\n      const callbacks = client.map((c) => c[method]);\n      const sendCall = (...args) => {\n        return Promise.all(callbacks.map((i) => i(...args)));\n      };\n      sendCall.asEvent = async (...args) => {\n        await Promise.all(callbacks.map((i) => i.asEvent(...args)));\n      };\n      return sendCall;\n    }\n  });\n  function updateChannels(fn) {\n    const channels2 = getChannels();\n    fn?.(channels2);\n    return getClients(channels2);\n  }\n  getClients();\n  return {\n    get clients() {\n      return getClients();\n    },\n    functions,\n    updateChannels,\n    broadcast: broadcastProxy,\n    /**\n     * @deprecated use `broadcast`\n     */\n    // @ts-expect-error deprecated\n    boardcast: broadcastProxy\n  };\n}\nfunction createPromiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\nconst urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction nanoid(size = 21) {\n  let id = \"\";\n  let i = size;\n  while (i--)\n    id += urlAlphabet[random() * 64 | 0];\n  return id;\n}\n\nexport { DEFAULT_TIMEOUT, cachedMap, createBirpc, createBirpcGroup };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}