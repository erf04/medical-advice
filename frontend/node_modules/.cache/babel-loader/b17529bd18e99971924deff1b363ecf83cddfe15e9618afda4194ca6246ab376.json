{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.map.get-or-insert.js\";\nimport \"core-js/modules/es.map.get-or-insert-computed.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/*!\n * vue-router v5.0.2\n * (c) 2026 Eduardo San Martin Morote\n * @license MIT\n */\nimport { a as routerKey, b as isBrowser, c as ErrorTypes, d as isNavigationFailure, f as applyToParams, h as isArray, i as routeLocationKey, l as NavigationFailureType, n as useRouter, o as routerViewLocationKey, p as assign, r as matchedRouteKey, s as viewDepthKey, t as useRoute, u as createRouterError, v as mergeOptions, y as noop } from \"./useApi-o-nPpLEi.mjs\";\nimport { C as normalizeBase, D as isSameRouteLocationParams, E as isSameRouteLocation, F as encodeParam, L as warn$1, M as stripBase, N as decode, O as isSameRouteRecord, P as encodeHash, S as createHref, T as START_LOCATION_NORMALIZED, _ as saveScrollPosition, a as loadRouteLocation, b as NavigationType, c as useCallbacks, d as stringifyQuery, f as isRouteLocation, g as getScrollKey, h as getSavedScrollPosition, i as guardToPromiseFn, j as stringifyURL, k as parseURL, l as normalizeQuery, m as computeScrollPosition, n as extractChangingRecords, o as onBeforeRouteLeave, p as isRouteName, r as extractComponentsGuards, s as onBeforeRouteUpdate, t as addDevtools, u as parseQuery, v as scrollToPosition, x as START, y as NavigationDirection } from \"./devtools-CQC1vVRY.mjs\";\nimport { computed, defineComponent, getCurrentInstance, h, inject, nextTick, provide, reactive, ref, shallowReactive, shallowRef, unref, watch, watchEffect } from \"vue\";\n\n//#region src/history/html5.ts\nlet createBaseLocation = () => location.protocol + \"//\" + location.host;\n/**\n* Creates a normalized history location from a window.location object\n* @param base - The base path\n* @param location - The window.location object\n*/\nfunction createCurrentLocation(base, location) {\n  const {\n    pathname,\n    search,\n    hash\n  } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") pathFromHash = \"/\" + pathFromHash;\n    return stripBase(pathFromHash, \"\");\n  }\n  return stripBase(pathname, base) + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n  let listeners = [];\n  let teardowns = [];\n  let pauseState = null;\n  const popStateHandler = ({\n    state\n  }) => {\n    const to = createCurrentLocation(base, location);\n    const from = currentLocation.value;\n    const fromState = historyState.value;\n    let delta = 0;\n    if (state) {\n      currentLocation.value = to;\n      historyState.value = state;\n      if (pauseState && pauseState === from) {\n        pauseState = null;\n        return;\n      }\n      delta = fromState ? state.position - fromState.position : 0;\n    } else replace(to);\n    listeners.forEach(listener => {\n      listener(currentLocation.value, from, {\n        delta,\n        type: NavigationType.pop,\n        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n      });\n    });\n  };\n  function pauseListeners() {\n    pauseState = currentLocation.value;\n  }\n  function listen(callback) {\n    listeners.push(callback);\n    const teardown = () => {\n      const index = listeners.indexOf(callback);\n      if (index > -1) listeners.splice(index, 1);\n    };\n    teardowns.push(teardown);\n    return teardown;\n  }\n  function beforeUnloadListener() {\n    if (document.visibilityState === \"hidden\") {\n      const {\n        history\n      } = window;\n      if (!history.state) return;\n      history.replaceState(assign({}, history.state, {\n        scroll: computeScrollPosition()\n      }), \"\");\n    }\n  }\n  function destroy() {\n    for (const teardown of teardowns) teardown();\n    teardowns = [];\n    window.removeEventListener(\"popstate\", popStateHandler);\n    window.removeEventListener(\"pagehide\", beforeUnloadListener);\n    document.removeEventListener(\"visibilitychange\", beforeUnloadListener);\n  }\n  window.addEventListener(\"popstate\", popStateHandler);\n  window.addEventListener(\"pagehide\", beforeUnloadListener);\n  document.addEventListener(\"visibilitychange\", beforeUnloadListener);\n  return {\n    pauseListeners,\n    listen,\n    destroy\n  };\n}\n/**\n* Creates a state object\n*/\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n  return {\n    back,\n    current,\n    forward,\n    replaced,\n    position: window.history.length,\n    scroll: computeScroll ? computeScrollPosition() : null\n  };\n}\nfunction useHistoryStateNavigation(base) {\n  const {\n    history,\n    location\n  } = window;\n  const currentLocation = {\n    value: createCurrentLocation(base, location)\n  };\n  const historyState = {\n    value: history.state\n  };\n  if (!historyState.value) changeLocation(currentLocation.value, {\n    back: null,\n    current: currentLocation.value,\n    forward: null,\n    position: history.length - 1,\n    replaced: true,\n    scroll: null\n  }, true);\n  function changeLocation(to, state, replace) {\n    /**\n    * if a base tag is provided, and we are on a normal domain, we have to\n    * respect the provided `base` attribute because pushState() will use it and\n    * potentially erase anything before the `#` like at\n    * https://github.com/vuejs/router/issues/685 where a base of\n    * `/folder/#` but a base of `/` would erase the `/folder/` section. If\n    * there is no host, the `<base>` tag makes no sense and if there isn't a\n    * base tag we can just use everything after the `#`.\n    */\n    const hashIndex = base.indexOf(\"#\");\n    const url = hashIndex > -1 ? (location.host && document.querySelector(\"base\") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n    try {\n      history[replace ? \"replaceState\" : \"pushState\"](state, \"\", url);\n      historyState.value = state;\n    } catch (err) {\n      if (process.env.NODE_ENV !== \"production\") warn$1(\"Error with push/replace State\", err);else console.error(err);\n      location[replace ? \"replace\" : \"assign\"](url);\n    }\n  }\n  function replace(to, data) {\n    changeLocation(to, assign({}, history.state, buildState(historyState.value.back, to, historyState.value.forward, true), data, {\n      position: historyState.value.position\n    }), true);\n    currentLocation.value = to;\n  }\n  function push(to, data) {\n    const currentState = assign({}, historyState.value, history.state, {\n      forward: to,\n      scroll: computeScrollPosition()\n    });\n    if (process.env.NODE_ENV !== \"production\" && !history.state) warn$1(\"history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\nhistory.replaceState(history.state, '', url)\\n\\nYou can find more information at https://router.vuejs.org/guide/migration/#Usage-of-history-state\");\n    changeLocation(currentState.current, currentState, true);\n    changeLocation(to, assign({}, buildState(currentLocation.value, to, null), {\n      position: currentState.position + 1\n    }, data), false);\n    currentLocation.value = to;\n  }\n  return {\n    location: currentLocation,\n    state: historyState,\n    push,\n    replace\n  };\n}\n/**\n* Creates an HTML5 history. Most common history for single page applications.\n*\n* @param base -\n*/\nfunction createWebHistory(base) {\n  base = normalizeBase(base);\n  const historyNavigation = useHistoryStateNavigation(base);\n  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n  function go(delta, triggerListeners = true) {\n    if (!triggerListeners) historyListeners.pauseListeners();\n    history.go(delta);\n  }\n  const routerHistory = assign({\n    location: \"\",\n    base,\n    go,\n    createHref: createHref.bind(null, base)\n  }, historyNavigation, historyListeners);\n  Object.defineProperty(routerHistory, \"location\", {\n    enumerable: true,\n    get: () => historyNavigation.location.value\n  });\n  Object.defineProperty(routerHistory, \"state\", {\n    enumerable: true,\n    get: () => historyNavigation.state.value\n  });\n  return routerHistory;\n}\n\n//#endregion\n//#region src/history/memory.ts\n/**\n* Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\n* It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\n*\n* @param base - Base applied to all urls, defaults to '/'\n* @returns a history object that can be passed to the router constructor\n*/\nfunction createMemoryHistory(base = \"\") {\n  let listeners = [];\n  let queue = [[START, {}]];\n  let position = 0;\n  base = normalizeBase(base);\n  function setLocation(location, state = {}) {\n    position++;\n    if (position !== queue.length) queue.splice(position);\n    queue.push([location, state]);\n  }\n  function triggerListeners(to, from, {\n    direction,\n    delta\n  }) {\n    const info = {\n      direction,\n      delta,\n      type: NavigationType.pop\n    };\n    for (const callback of listeners) callback(to, from, info);\n  }\n  const routerHistory = {\n    location: START,\n    state: {},\n    base,\n    createHref: createHref.bind(null, base),\n    replace(to, state) {\n      queue.splice(position--, 1);\n      setLocation(to, state);\n    },\n    push(to, state) {\n      setLocation(to, state);\n    },\n    listen(callback) {\n      listeners.push(callback);\n      return () => {\n        const index = listeners.indexOf(callback);\n        if (index > -1) listeners.splice(index, 1);\n      };\n    },\n    destroy() {\n      listeners = [];\n      queue = [[START, {}]];\n      position = 0;\n    },\n    go(delta, shouldTrigger = true) {\n      const from = this.location;\n      const direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n      position = Math.max(0, Math.min(position + delta, queue.length - 1));\n      if (shouldTrigger) triggerListeners(this.location, from, {\n        direction,\n        delta\n      });\n    }\n  };\n  Object.defineProperty(routerHistory, \"location\", {\n    enumerable: true,\n    get: () => queue[position][0]\n  });\n  Object.defineProperty(routerHistory, \"state\", {\n    enumerable: true,\n    get: () => queue[position][1]\n  });\n  return routerHistory;\n}\n\n//#endregion\n//#region src/history/hash.ts\n/**\n* Creates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to\n* handle any URL is not possible.\n*\n* @param base - optional base to provide. Defaults to `location.pathname + location.search` If there is a `<base>` tag\n* in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState()\n* calls**, meaning that if you use a `<base>` tag, it's `href` value **has to match this parameter** (ignoring anything\n* after the `#`).\n*\n* @example\n* ```js\n* // at https://example.com/folder\n* createWebHashHistory() // gives a url of `https://example.com/folder#`\n* createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n* // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n* createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n* // you should avoid doing this because it changes the original url and breaks copying urls\n* createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n*\n* // at file:///usr/etc/folder/index.html\n* // for locations with no `host`, the base is ignored\n* createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n* ```\n*/\nfunction createWebHashHistory(base) {\n  base = location.host ? base || location.pathname + location.search : \"\";\n  if (!base.includes(\"#\")) base += \"#\";\n  if (process.env.NODE_ENV !== \"production\" && !base.endsWith(\"#/\") && !base.endsWith(\"#\")) warn$1(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, \"#\")}\".`);\n  return createWebHistory(base);\n}\n\n//#endregion\n//#region src/matcher/pathTokenizer.ts\nlet TokenType = /* @__PURE__ */function (TokenType) {\n  TokenType[TokenType[\"Static\"] = 0] = \"Static\";\n  TokenType[TokenType[\"Param\"] = 1] = \"Param\";\n  TokenType[TokenType[\"Group\"] = 2] = \"Group\";\n  return TokenType;\n}({});\nvar TokenizerState = /* @__PURE__ */function (TokenizerState) {\n  TokenizerState[TokenizerState[\"Static\"] = 0] = \"Static\";\n  TokenizerState[TokenizerState[\"Param\"] = 1] = \"Param\";\n  TokenizerState[TokenizerState[\"ParamRegExp\"] = 2] = \"ParamRegExp\";\n  TokenizerState[TokenizerState[\"ParamRegExpEnd\"] = 3] = \"ParamRegExpEnd\";\n  TokenizerState[TokenizerState[\"EscapeNext\"] = 4] = \"EscapeNext\";\n  return TokenizerState;\n}(TokenizerState || {});\nconst ROOT_TOKEN = {\n  type: TokenType.Static,\n  value: \"\"\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\nfunction tokenizePath(path) {\n  if (!path) return [[]];\n  if (path === \"/\") return [[ROOT_TOKEN]];\n  if (!path.startsWith(\"/\")) throw new Error(process.env.NODE_ENV !== \"production\" ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".` : `Invalid path \"${path}\"`);\n  function crash(message) {\n    throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n  }\n  let state = TokenizerState.Static;\n  let previousState = state;\n  const tokens = [];\n  let segment;\n  function finalizeSegment() {\n    if (segment) tokens.push(segment);\n    segment = [];\n  }\n  let i = 0;\n  let char;\n  let buffer = \"\";\n  let customRe = \"\";\n  function consumeBuffer() {\n    if (!buffer) return;\n    if (state === TokenizerState.Static) segment.push({\n      type: TokenType.Static,\n      value: buffer\n    });else if (state === TokenizerState.Param || state === TokenizerState.ParamRegExp || state === TokenizerState.ParamRegExpEnd) {\n      if (segment.length > 1 && (char === \"*\" || char === \"+\")) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n      segment.push({\n        type: TokenType.Param,\n        value: buffer,\n        regexp: customRe,\n        repeatable: char === \"*\" || char === \"+\",\n        optional: char === \"*\" || char === \"?\"\n      });\n    } else crash(\"Invalid state to consume buffer\");\n    buffer = \"\";\n  }\n  function addCharToBuffer() {\n    buffer += char;\n  }\n  while (i < path.length) {\n    char = path[i++];\n    if (char === \"\\\\\" && state !== TokenizerState.ParamRegExp) {\n      previousState = state;\n      state = TokenizerState.EscapeNext;\n      continue;\n    }\n    switch (state) {\n      case TokenizerState.Static:\n        if (char === \"/\") {\n          if (buffer) consumeBuffer();\n          finalizeSegment();\n        } else if (char === \":\") {\n          consumeBuffer();\n          state = TokenizerState.Param;\n        } else addCharToBuffer();\n        break;\n      case TokenizerState.EscapeNext:\n        addCharToBuffer();\n        state = previousState;\n        break;\n      case TokenizerState.Param:\n        if (char === \"(\") state = TokenizerState.ParamRegExp;else if (VALID_PARAM_RE.test(char)) addCharToBuffer();else {\n          consumeBuffer();\n          state = TokenizerState.Static;\n          if (char !== \"*\" && char !== \"?\" && char !== \"+\") i--;\n        }\n        break;\n      case TokenizerState.ParamRegExp:\n        if (char === \")\") {\n          if (customRe[customRe.length - 1] == \"\\\\\") customRe = customRe.slice(0, -1) + char;else state = TokenizerState.ParamRegExpEnd;\n        } else customRe += char;\n        break;\n      case TokenizerState.ParamRegExpEnd:\n        consumeBuffer();\n        state = TokenizerState.Static;\n        if (char !== \"*\" && char !== \"?\" && char !== \"+\") i--;\n        customRe = \"\";\n        break;\n      default:\n        crash(\"Unknown state\");\n        break;\n    }\n  }\n  if (state === TokenizerState.ParamRegExp) crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n  consumeBuffer();\n  finalizeSegment();\n  return tokens;\n}\n\n//#endregion\n//#region src/matcher/pathParserRanker.ts\nconst BASE_PARAM_PATTERN = \"[^/]+?\";\nconst BASE_PATH_PARSER_OPTIONS = {\n  sensitive: false,\n  strict: false,\n  start: true,\n  end: true\n};\nvar PathScore = /* @__PURE__ */function (PathScore) {\n  PathScore[PathScore[\"_multiplier\"] = 10] = \"_multiplier\";\n  PathScore[PathScore[\"Root\"] = 90] = \"Root\";\n  PathScore[PathScore[\"Segment\"] = 40] = \"Segment\";\n  PathScore[PathScore[\"SubSegment\"] = 30] = \"SubSegment\";\n  PathScore[PathScore[\"Static\"] = 40] = \"Static\";\n  PathScore[PathScore[\"Dynamic\"] = 20] = \"Dynamic\";\n  PathScore[PathScore[\"BonusCustomRegExp\"] = 10] = \"BonusCustomRegExp\";\n  PathScore[PathScore[\"BonusWildcard\"] = -50] = \"BonusWildcard\";\n  PathScore[PathScore[\"BonusRepeatable\"] = -20] = \"BonusRepeatable\";\n  PathScore[PathScore[\"BonusOptional\"] = -8] = \"BonusOptional\";\n  PathScore[PathScore[\"BonusStrict\"] = .7000000000000001] = \"BonusStrict\";\n  PathScore[PathScore[\"BonusCaseSensitive\"] = .25] = \"BonusCaseSensitive\";\n  return PathScore;\n}(PathScore || {});\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\n* Creates a path parser from an array of Segments (a segment is an array of Tokens)\n*\n* @param segments - array of segments returned by tokenizePath\n* @param extraOptions - optional options for the regexp\n* @returns a PathParser\n*/\nfunction tokensToParser(segments, extraOptions) {\n  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n  const score = [];\n  let pattern = options.start ? \"^\" : \"\";\n  const keys = [];\n  for (const segment of segments) {\n    const segmentScores = segment.length ? [] : [PathScore.Root];\n    if (options.strict && !segment.length) pattern += \"/\";\n    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n      const token = segment[tokenIndex];\n      let subSegmentScore = PathScore.Segment + (options.sensitive ? PathScore.BonusCaseSensitive : 0);\n      if (token.type === TokenType.Static) {\n        if (!tokenIndex) pattern += \"/\";\n        pattern += token.value.replace(REGEX_CHARS_RE, \"\\\\$&\");\n        subSegmentScore += PathScore.Static;\n      } else if (token.type === TokenType.Param) {\n        const {\n          value,\n          repeatable,\n          optional,\n          regexp\n        } = token;\n        keys.push({\n          name: value,\n          repeatable,\n          optional\n        });\n        const re = regexp ? regexp : BASE_PARAM_PATTERN;\n        if (re !== BASE_PARAM_PATTERN) {\n          subSegmentScore += PathScore.BonusCustomRegExp;\n          try {\n            new RegExp(`(${re})`);\n          } catch (err) {\n            throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` + err.message);\n          }\n        }\n        let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\n        if (!tokenIndex) subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : \"/\" + subPattern;\n        if (optional) subPattern += \"?\";\n        pattern += subPattern;\n        subSegmentScore += PathScore.Dynamic;\n        if (optional) subSegmentScore += PathScore.BonusOptional;\n        if (repeatable) subSegmentScore += PathScore.BonusRepeatable;\n        if (re === \".*\") subSegmentScore += PathScore.BonusWildcard;\n      }\n      segmentScores.push(subSegmentScore);\n    }\n    score.push(segmentScores);\n  }\n  if (options.strict && options.end) {\n    const i = score.length - 1;\n    score[i][score[i].length - 1] += PathScore.BonusStrict;\n  }\n  if (!options.strict) pattern += \"/?\";\n  if (options.end) pattern += \"$\";else if (options.strict && !pattern.endsWith(\"/\")) pattern += \"(?:/|$)\";\n  const re = new RegExp(pattern, options.sensitive ? \"\" : \"i\");\n  function parse(path) {\n    const match = path.match(re);\n    const params = {};\n    if (!match) return null;\n    for (let i = 1; i < match.length; i++) {\n      const value = match[i] || \"\";\n      const key = keys[i - 1];\n      params[key.name] = value && key.repeatable ? value.split(\"/\") : value;\n    }\n    return params;\n  }\n  function stringify(params) {\n    let path = \"\";\n    let avoidDuplicatedSlash = false;\n    for (const segment of segments) {\n      if (!avoidDuplicatedSlash || !path.endsWith(\"/\")) path += \"/\";\n      avoidDuplicatedSlash = false;\n      for (const token of segment) if (token.type === TokenType.Static) path += token.value;else if (token.type === TokenType.Param) {\n        const {\n          value,\n          repeatable,\n          optional\n        } = token;\n        const param = value in params ? params[value] : \"\";\n        if (isArray(param) && !repeatable) throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n        const text = isArray(param) ? param.join(\"/\") : param;\n        if (!text) if (optional) {\n          if (segment.length < 2) if (path.endsWith(\"/\")) path = path.slice(0, -1);else avoidDuplicatedSlash = true;\n        } else throw new Error(`Missing required param \"${value}\"`);\n        path += text;\n      }\n    }\n    return path || \"/\";\n  }\n  return {\n    re,\n    score,\n    keys,\n    parse,\n    stringify\n  };\n}\n/**\n* Compares an array of numbers as used in PathParser.score and returns a\n* number. This function can be used to `sort` an array\n*\n* @param a - first array of numbers\n* @param b - second array of numbers\n* @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n* should be sorted first\n*/\nfunction compareScoreArray(a, b) {\n  let i = 0;\n  while (i < a.length && i < b.length) {\n    const diff = b[i] - a[i];\n    if (diff) return diff;\n    i++;\n  }\n  if (a.length < b.length) return a.length === 1 && a[0] === PathScore.Static + PathScore.Segment ? -1 : 1;else if (a.length > b.length) return b.length === 1 && b[0] === PathScore.Static + PathScore.Segment ? 1 : -1;\n  return 0;\n}\n/**\n* Compare function that can be used with `sort` to sort an array of PathParser\n*\n* @param a - first PathParser\n* @param b - second PathParser\n* @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n*/\nfunction comparePathParserScore(a, b) {\n  let i = 0;\n  const aScore = a.score;\n  const bScore = b.score;\n  while (i < aScore.length && i < bScore.length) {\n    const comp = compareScoreArray(aScore[i], bScore[i]);\n    if (comp) return comp;\n    i++;\n  }\n  if (Math.abs(bScore.length - aScore.length) === 1) {\n    if (isLastScoreNegative(aScore)) return 1;\n    if (isLastScoreNegative(bScore)) return -1;\n  }\n  return bScore.length - aScore.length;\n}\n/**\n* This allows detecting splats at the end of a path: /home/:id(.*)*\n*\n* @param score - score to check\n* @returns true if the last entry is negative\n*/\nfunction isLastScoreNegative(score) {\n  const last = score[score.length - 1];\n  return score.length > 0 && last[last.length - 1] < 0;\n}\nconst PATH_PARSER_OPTIONS_DEFAULTS = {\n  strict: false,\n  end: true,\n  sensitive: false\n};\n\n//#endregion\n//#region src/matcher/pathMatcher.ts\nfunction createRouteRecordMatcher(record, parent, options) {\n  const parser = tokensToParser(tokenizePath(record.path), options);\n  if (process.env.NODE_ENV !== \"production\") {\n    const existingKeys = /* @__PURE__ */new Set();\n    for (const key of parser.keys) {\n      if (existingKeys.has(key.name)) warn$1(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n      existingKeys.add(key.name);\n    }\n  }\n  const matcher = assign(parser, {\n    record,\n    parent,\n    children: [],\n    alias: []\n  });\n  if (parent) {\n    if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);\n  }\n  return matcher;\n}\n\n//#endregion\n//#region src/matcher/index.ts\n/**\n* Creates a Router Matcher.\n*\n* @internal\n* @param routes - array of initial routes\n* @param globalOptions - global route options\n*/\nfunction createRouterMatcher(routes, globalOptions) {\n  const matchers = [];\n  const matcherMap = /* @__PURE__ */new Map();\n  globalOptions = mergeOptions(PATH_PARSER_OPTIONS_DEFAULTS, globalOptions);\n  function getRecordMatcher(name) {\n    return matcherMap.get(name);\n  }\n  function addRoute(record, parent, originalRecord) {\n    const isRootAdd = !originalRecord;\n    const mainNormalizedRecord = normalizeRouteRecord(record);\n    if (process.env.NODE_ENV !== \"production\") checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);\n    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n    const options = mergeOptions(globalOptions, record);\n    const normalizedRecords = [mainNormalizedRecord];\n    if (\"alias\" in record) {\n      const aliases = typeof record.alias === \"string\" ? [record.alias] : record.alias;\n      for (const alias of aliases) normalizedRecords.push(normalizeRouteRecord(assign({}, mainNormalizedRecord, {\n        components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n        path: alias,\n        aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord\n      })));\n    }\n    let matcher;\n    let originalMatcher;\n    for (const normalizedRecord of normalizedRecords) {\n      const {\n        path\n      } = normalizedRecord;\n      if (parent && path[0] !== \"/\") {\n        const parentPath = parent.record.path;\n        const connectingSlash = parentPath[parentPath.length - 1] === \"/\" ? \"\" : \"/\";\n        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n      }\n      if (process.env.NODE_ENV !== \"production\" && normalizedRecord.path === \"*\") throw new Error(\"Catch all routes (\\\"*\\\") must now be defined using a param with a custom regexp.\\nSee more at https://router.vuejs.org/guide/migration/#Removed-star-or-catch-all-routes.\");\n      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n      if (process.env.NODE_ENV !== \"production\" && parent && path[0] === \"/\") checkMissingParamsInAbsolutePath(matcher, parent);\n      if (originalRecord) {\n        originalRecord.alias.push(matcher);\n        if (process.env.NODE_ENV !== \"production\") checkSameParams(originalRecord, matcher);\n      } else {\n        originalMatcher = originalMatcher || matcher;\n        if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);\n        if (isRootAdd && record.name && !isAliasRecord(matcher)) {\n          if (process.env.NODE_ENV !== \"production\") checkSameNameAsAncestor(record, parent);\n          removeRoute(record.name);\n        }\n      }\n      if (isMatchable(matcher)) insertMatcher(matcher);\n      if (mainNormalizedRecord.children) {\n        const children = mainNormalizedRecord.children;\n        for (let i = 0; i < children.length; i++) addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n      }\n      originalRecord = originalRecord || matcher;\n    }\n    return originalMatcher ? () => {\n      removeRoute(originalMatcher);\n    } : noop;\n  }\n  function removeRoute(matcherRef) {\n    if (isRouteName(matcherRef)) {\n      const matcher = matcherMap.get(matcherRef);\n      if (matcher) {\n        matcherMap.delete(matcherRef);\n        matchers.splice(matchers.indexOf(matcher), 1);\n        matcher.children.forEach(removeRoute);\n        matcher.alias.forEach(removeRoute);\n      }\n    } else {\n      const index = matchers.indexOf(matcherRef);\n      if (index > -1) {\n        matchers.splice(index, 1);\n        if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);\n        matcherRef.children.forEach(removeRoute);\n        matcherRef.alias.forEach(removeRoute);\n      }\n    }\n  }\n  function getRoutes() {\n    return matchers;\n  }\n  function insertMatcher(matcher) {\n    const index = findInsertionIndex(matcher, matchers);\n    matchers.splice(index, 0, matcher);\n    if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);\n  }\n  function resolve(location, currentLocation) {\n    let matcher;\n    let params = {};\n    let path;\n    let name;\n    if (\"name\" in location && location.name) {\n      matcher = matcherMap.get(location.name);\n      if (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, {\n        location\n      });\n      if (process.env.NODE_ENV !== \"production\") {\n        const invalidParams = Object.keys(location.params || {}).filter(paramName => !matcher.keys.find(k => k.name === paramName));\n        if (invalidParams.length) warn$1(`Discarded invalid param(s) \"${invalidParams.join(\"\\\", \\\"\")}\" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);\n      }\n      name = matcher.record.name;\n      params = assign(pickParams(currentLocation.params, matcher.keys.filter(k => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter(k => k.optional) : []).map(k => k.name)), location.params && pickParams(location.params, matcher.keys.map(k => k.name)));\n      path = matcher.stringify(params);\n    } else if (location.path != null) {\n      path = location.path;\n      if (process.env.NODE_ENV !== \"production\" && !path.startsWith(\"/\")) warn$1(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`);\n      matcher = matchers.find(m => m.re.test(path));\n      if (matcher) {\n        params = matcher.parse(path);\n        name = matcher.record.name;\n      }\n    } else {\n      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find(m => m.re.test(currentLocation.path));\n      if (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, {\n        location,\n        currentLocation\n      });\n      name = matcher.record.name;\n      params = assign({}, currentLocation.params, location.params);\n      path = matcher.stringify(params);\n    }\n    const matched = [];\n    let parentMatcher = matcher;\n    while (parentMatcher) {\n      matched.unshift(parentMatcher.record);\n      parentMatcher = parentMatcher.parent;\n    }\n    return {\n      name,\n      path,\n      params,\n      matched,\n      meta: mergeMetaFields(matched)\n    };\n  }\n  routes.forEach(route => addRoute(route));\n  function clearRoutes() {\n    matchers.length = 0;\n    matcherMap.clear();\n  }\n  return {\n    addRoute,\n    resolve,\n    removeRoute,\n    clearRoutes,\n    getRoutes,\n    getRecordMatcher\n  };\n}\n/**\n* Picks an object param to contain only specified keys.\n*\n* @param params - params object to pick from\n* @param keys - keys to pick\n*/\nfunction pickParams(params, keys) {\n  const newParams = {};\n  for (const key of keys) if (key in params) newParams[key] = params[key];\n  return newParams;\n}\n/**\n* Normalizes a RouteRecordRaw. Creates a copy\n*\n* @param record\n* @returns the normalized version\n*/\nfunction normalizeRouteRecord(record) {\n  const normalized = {\n    path: record.path,\n    redirect: record.redirect,\n    name: record.name,\n    meta: record.meta || {},\n    aliasOf: record.aliasOf,\n    beforeEnter: record.beforeEnter,\n    props: normalizeRecordProps(record),\n    children: record.children || [],\n    instances: {},\n    leaveGuards: /* @__PURE__ */new Set(),\n    updateGuards: /* @__PURE__ */new Set(),\n    enterCallbacks: {},\n    components: \"components\" in record ? record.components || null : record.component && {\n      default: record.component\n    }\n  };\n  Object.defineProperty(normalized, \"mods\", {\n    value: {}\n  });\n  return normalized;\n}\n/**\n* Normalize the optional `props` in a record to always be an object similar to\n* components. Also accept a boolean for components.\n* @param record\n*/\nfunction normalizeRecordProps(record) {\n  const propsObject = {};\n  const props = record.props || false;\n  if (\"component\" in record) propsObject.default = props;else for (const name in record.components) propsObject[name] = typeof props === \"object\" ? props[name] : props;\n  return propsObject;\n}\n/**\n* Checks if a record or any of its parent is an alias\n* @param record\n*/\nfunction isAliasRecord(record) {\n  while (record) {\n    if (record.record.aliasOf) return true;\n    record = record.parent;\n  }\n  return false;\n}\n/**\n* Merge meta fields of an array of records\n*\n* @param matched - array of matched records\n*/\nfunction mergeMetaFields(matched) {\n  return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction isSameParam(a, b) {\n  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\n/**\n* Check if a path and its alias have the same required params\n*\n* @param a - original record\n* @param b - alias record\n*/\nfunction checkSameParams(a, b) {\n  for (const key of a.keys) if (!key.optional && !b.keys.find(isSameParam.bind(null, key))) return warn$1(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n  for (const key of b.keys) if (!key.optional && !a.keys.find(isSameParam.bind(null, key))) return warn$1(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n}\n/**\n* A route with a name and a child with an empty path without a name should warn when adding the route\n*\n* @param mainNormalizedRecord - RouteRecordNormalized\n* @param parent - RouteRecordMatcher\n*/\nfunction checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {\n  if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path && mainNormalizedRecord.children.length === 0) warn$1(`The route named \"${String(parent.record.name)}\" has a child without a name, an empty path, and no children. This is probably a mistake: using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to silence the warning.`);\n}\nfunction checkSameNameAsAncestor(record, parent) {\n  for (let ancestor = parent; ancestor; ancestor = ancestor.parent) if (ancestor.record.name === record.name) throw new Error(`A route named \"${String(record.name)}\" has been added as a ${parent === ancestor ? \"child\" : \"descendant\"} of a route with the same name. Route names must be unique and a nested route cannot use the same name as an ancestor.`);\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n  for (const key of parent.keys) if (!record.keys.find(isSameParam.bind(null, key))) return warn$1(`Absolute path \"${record.record.path}\" must have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n}\n/**\n* Performs a binary search to find the correct insertion index for a new matcher.\n*\n* Matchers are primarily sorted by their score. If scores are tied then we also consider parent/child relationships,\n* with descendants coming before ancestors. If there's still a tie, new routes are inserted after existing routes.\n*\n* @param matcher - new matcher to be inserted\n* @param matchers - existing matchers\n*/\nfunction findInsertionIndex(matcher, matchers) {\n  let lower = 0;\n  let upper = matchers.length;\n  while (lower !== upper) {\n    const mid = lower + upper >> 1;\n    if (comparePathParserScore(matcher, matchers[mid]) < 0) upper = mid;else lower = mid + 1;\n  }\n  const insertionAncestor = getInsertionAncestor(matcher);\n  if (insertionAncestor) {\n    upper = matchers.lastIndexOf(insertionAncestor, upper - 1);\n    if (process.env.NODE_ENV !== \"production\" && upper < 0) warn$1(`Finding ancestor route \"${insertionAncestor.record.path}\" failed for \"${matcher.record.path}\"`);\n  }\n  return upper;\n}\nfunction getInsertionAncestor(matcher) {\n  let ancestor = matcher;\n  while (ancestor = ancestor.parent) if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) return ancestor;\n}\n/**\n* Checks if a matcher can be reachable. This means if it's possible to reach it as a route. For example, routes without\n* a component, or name, or redirect, are just used to group other routes.\n* @param matcher\n* @param matcher.record record of the matcher\n* @returns\n*/\nfunction isMatchable({\n  record\n}) {\n  return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);\n}\n\n//#endregion\n//#region src/RouterLink.ts\n/**\n* Returns the internal behavior of a {@link RouterLink} without the rendering part.\n*\n* @param props - a `to` location and an optional `replace` flag\n*/\nfunction useLink(props) {\n  const router = inject(routerKey);\n  const currentRoute = inject(routeLocationKey);\n  let hasPrevious = false;\n  let previousTo = null;\n  const route = computed(() => {\n    const to = unref(props.to);\n    if (process.env.NODE_ENV !== \"production\" && (!hasPrevious || to !== previousTo)) {\n      if (!isRouteLocation(to)) if (hasPrevious) warn$1(`Invalid value for prop \"to\" in useLink()\\n- to:`, to, `\\n- previous to:`, previousTo, `\\n- props:`, props);else warn$1(`Invalid value for prop \"to\" in useLink()\\n- to:`, to, `\\n- props:`, props);\n      previousTo = to;\n      hasPrevious = true;\n    }\n    return router.resolve(to);\n  });\n  const activeRecordIndex = computed(() => {\n    const {\n      matched\n    } = route.value;\n    const {\n      length\n    } = matched;\n    const routeMatched = matched[length - 1];\n    const currentMatched = currentRoute.matched;\n    if (!routeMatched || !currentMatched.length) return -1;\n    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n    if (index > -1) return index;\n    const parentRecordPath = getOriginalPath(matched[length - 2]);\n    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;\n  });\n  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n  function navigate(e = {}) {\n    if (guardEvent(e)) {\n      const p = router[unref(props.replace) ? \"replace\" : \"push\"](unref(props.to)).catch(noop);\n      if (props.viewTransition && typeof document !== \"undefined\" && \"startViewTransition\" in document) document.startViewTransition(() => p);\n      return p;\n    }\n    return Promise.resolve();\n  }\n  if ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n    const instance = getCurrentInstance();\n    if (instance) {\n      const linkContextDevtools = {\n        route: route.value,\n        isActive: isActive.value,\n        isExactActive: isExactActive.value,\n        error: null\n      };\n      instance.__vrl_devtools = instance.__vrl_devtools || [];\n      instance.__vrl_devtools.push(linkContextDevtools);\n      watchEffect(() => {\n        linkContextDevtools.route = route.value;\n        linkContextDevtools.isActive = isActive.value;\n        linkContextDevtools.isExactActive = isExactActive.value;\n        linkContextDevtools.error = isRouteLocation(unref(props.to)) ? null : \"Invalid \\\"to\\\" value\";\n      }, {\n        flush: \"post\"\n      });\n    }\n  }\n  /**\n  * NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this\n  */\n  return {\n    route,\n    href: computed(() => route.value.href),\n    isActive,\n    isExactActive,\n    navigate\n  };\n}\nfunction preferSingleVNode(vnodes) {\n  return vnodes.length === 1 ? vnodes[0] : vnodes;\n}\nconst RouterLinkImpl = /* @__PURE__ */defineComponent({\n  name: \"RouterLink\",\n  compatConfig: {\n    MODE: 3\n  },\n  props: {\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    custom: Boolean,\n    ariaCurrentValue: {\n      type: String,\n      default: \"page\"\n    },\n    viewTransition: Boolean\n  },\n  useLink,\n  setup(props, {\n    slots\n  }) {\n    const link = reactive(useLink(props));\n    const {\n      options\n    } = inject(routerKey);\n    const elClass = computed(() => ({\n      [getLinkClass(props.activeClass, options.linkActiveClass, \"router-link-active\")]: link.isActive,\n      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, \"router-link-exact-active\")]: link.isExactActive\n    }));\n    return () => {\n      const children = slots.default && preferSingleVNode(slots.default(link));\n      return props.custom ? children : h(\"a\", {\n        \"aria-current\": link.isExactActive ? props.ariaCurrentValue : null,\n        href: link.href,\n        onClick: link.navigate,\n        class: elClass.value\n      }, children);\n    };\n  }\n});\n/**\n* Component to render a link that triggers a navigation on click.\n*/\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;\n  if (e.defaultPrevented) return;\n  if (e.button !== void 0 && e.button !== 0) return;\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    const target = e.currentTarget.getAttribute(\"target\");\n    if (/\\b_blank\\b/i.test(target)) return;\n  }\n  if (e.preventDefault) e.preventDefault();\n  return true;\n}\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n    if (typeof innerValue === \"string\") {\n      if (innerValue !== outerValue) return false;\n    } else if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value.valueOf() !== outerValue[i].valueOf())) return false;\n  }\n  return true;\n}\n/**\n* Get the original path value of a record by following its aliasOf\n* @param record\n*/\nfunction getOriginalPath(record) {\n  return record ? record.aliasOf ? record.aliasOf.path : record.path : \"\";\n}\n/**\n* Utility class to get the active class based on defaults.\n* @param propClass\n* @param globalClass\n* @param defaultClass\n*/\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\n\n//#endregion\n//#region src/RouterView.ts\nconst RouterViewImpl = /* @__PURE__ */defineComponent({\n  name: \"RouterView\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String,\n      default: \"default\"\n    },\n    route: Object\n  },\n  compatConfig: {\n    MODE: 3\n  },\n  setup(props, {\n    attrs,\n    slots\n  }) {\n    process.env.NODE_ENV !== \"production\" && warnDeprecatedUsage();\n    const injectedRoute = inject(routerViewLocationKey);\n    const routeToDisplay = computed(() => props.route || injectedRoute.value);\n    const injectedDepth = inject(viewDepthKey, 0);\n    const depth = computed(() => {\n      let initialDepth = unref(injectedDepth);\n      const {\n        matched\n      } = routeToDisplay.value;\n      let matchedRoute;\n      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) initialDepth++;\n      return initialDepth;\n    });\n    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);\n    provide(viewDepthKey, computed(() => depth.value + 1));\n    provide(matchedRouteKey, matchedRouteRef);\n    provide(routerViewLocationKey, routeToDisplay);\n    const viewRef = ref();\n    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n      if (to) {\n        to.instances[name] = instance;\n        if (from && from !== to && instance && instance === oldInstance) {\n          if (!to.leaveGuards.size) to.leaveGuards = from.leaveGuards;\n          if (!to.updateGuards.size) to.updateGuards = from.updateGuards;\n        }\n      }\n      if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\n    }, {\n      flush: \"post\"\n    });\n    return () => {\n      const route = routeToDisplay.value;\n      const currentName = props.name;\n      const matchedRoute = matchedRouteRef.value;\n      const ViewComponent = matchedRoute && matchedRoute.components[currentName];\n      if (!ViewComponent) return normalizeSlot(slots.default, {\n        Component: ViewComponent,\n        route\n      });\n      const routePropsOption = matchedRoute.props[currentName];\n      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === \"function\" ? routePropsOption(route) : routePropsOption : null;\n      const onVnodeUnmounted = vnode => {\n        if (vnode.component.isUnmounted) matchedRoute.instances[currentName] = null;\n      };\n      const component = h(ViewComponent, assign({}, routeProps, attrs, {\n        onVnodeUnmounted,\n        ref: viewRef\n      }));\n      if ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser && component.ref) {\n        const info = {\n          depth: depth.value,\n          name: matchedRoute.name,\n          path: matchedRoute.path,\n          meta: matchedRoute.meta\n        };\n        (isArray(component.ref) ? component.ref.map(r => r.i) : [component.ref.i]).forEach(instance => {\n          instance.__vrv_devtools = info;\n        });\n      }\n      return normalizeSlot(slots.default, {\n        Component: component,\n        route\n      }) || component;\n    };\n  }\n});\nfunction normalizeSlot(slot, data) {\n  if (!slot) return null;\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n/**\n* Component to display the current route the user is at.\n*/\nconst RouterView = RouterViewImpl;\nfunction warnDeprecatedUsage() {\n  const instance = getCurrentInstance();\n  const parentName = instance.parent && instance.parent.type.name;\n  const parentSubTreeType = instance.parent && instance.parent.subTree && instance.parent.subTree.type;\n  if (parentName && (parentName === \"KeepAlive\" || parentName.includes(\"Transition\")) && typeof parentSubTreeType === \"object\" && parentSubTreeType.name === \"RouterView\") {\n    const comp = parentName === \"KeepAlive\" ? \"keep-alive\" : \"transition\";\n    warn$1(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\nUse slot props instead:\n\n<router-view v-slot=\"{ Component }\">\n  <${comp}>\\n    <component :is=\"Component\" />\\n  </${comp}>\\n</router-view>`);\n  }\n}\n\n//#endregion\n//#region src/router.ts\n/**\n* Creates a Router instance that can be used by a Vue app.\n*\n* @param options - {@link RouterOptions}\n*/\nfunction createRouter(options) {\n  const matcher = createRouterMatcher(options.routes, options);\n  const parseQuery$1 = options.parseQuery || parseQuery;\n  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n  const routerHistory = options.history;\n  if (process.env.NODE_ENV !== \"production\" && !routerHistory) throw new Error(\"Provide the \\\"history\\\" option when calling \\\"createRouter()\\\": https://router.vuejs.org/api/interfaces/RouterOptions.html#history\");\n  const beforeGuards = useCallbacks();\n  const beforeResolveGuards = useCallbacks();\n  const afterGuards = useCallbacks();\n  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n  let pendingLocation = START_LOCATION_NORMALIZED;\n  if (isBrowser && options.scrollBehavior && \"scrollRestoration\" in history) history.scrollRestoration = \"manual\";\n  const normalizeParams = applyToParams.bind(null, paramValue => \"\" + paramValue);\n  const encodeParams = applyToParams.bind(null, encodeParam);\n  const decodeParams = applyToParams.bind(null, decode);\n  function addRoute(parentOrRoute, route) {\n    let parent;\n    let record;\n    if (isRouteName(parentOrRoute)) {\n      parent = matcher.getRecordMatcher(parentOrRoute);\n      if (process.env.NODE_ENV !== \"production\" && !parent) warn$1(`Parent route \"${String(parentOrRoute)}\" not found when adding child route`, route);\n      record = route;\n    } else record = parentOrRoute;\n    return matcher.addRoute(record, parent);\n  }\n  function removeRoute(name) {\n    const recordMatcher = matcher.getRecordMatcher(name);\n    if (recordMatcher) matcher.removeRoute(recordMatcher);else if (process.env.NODE_ENV !== \"production\") warn$1(`Cannot remove non-existent route \"${String(name)}\"`);\n  }\n  function getRoutes() {\n    return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\n  }\n  function hasRoute(name) {\n    return !!matcher.getRecordMatcher(name);\n  }\n  function resolve(rawLocation, currentLocation) {\n    currentLocation = assign({}, currentLocation || currentRoute.value);\n    if (typeof rawLocation === \"string\") {\n      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n      const matchedRoute = matcher.resolve({\n        path: locationNormalized.path\n      }, currentLocation);\n      const href = routerHistory.createHref(locationNormalized.fullPath);\n      if (process.env.NODE_ENV !== \"production\") {\n        if (href.startsWith(\"//\")) warn$1(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);else if (!matchedRoute.matched.length) warn$1(`No match found for location with path \"${rawLocation}\"`);\n      }\n      return assign(locationNormalized, matchedRoute, {\n        params: decodeParams(matchedRoute.params),\n        hash: decode(locationNormalized.hash),\n        redirectedFrom: void 0,\n        href\n      });\n    }\n    if (process.env.NODE_ENV !== \"production\" && !isRouteLocation(rawLocation)) {\n      warn$1(`router.resolve() was passed an invalid location. This will fail in production.\\n- Location:`, rawLocation);\n      return resolve({});\n    }\n    let matcherLocation;\n    if (rawLocation.path != null) {\n      if (process.env.NODE_ENV !== \"production\" && \"params\" in rawLocation && !(\"name\" in rawLocation) && Object.keys(rawLocation.params).length) warn$1(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n      matcherLocation = assign({}, rawLocation, {\n        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path\n      });\n    } else {\n      const targetParams = assign({}, rawLocation.params);\n      for (const key in targetParams) if (targetParams[key] == null) delete targetParams[key];\n      matcherLocation = assign({}, rawLocation, {\n        params: encodeParams(targetParams)\n      });\n      currentLocation.params = encodeParams(currentLocation.params);\n    }\n    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n    const hash = rawLocation.hash || \"\";\n    if (process.env.NODE_ENV !== \"production\" && hash && !hash.startsWith(\"#\")) warn$1(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n      hash: encodeHash(hash),\n      path: matchedRoute.path\n    }));\n    const href = routerHistory.createHref(fullPath);\n    if (process.env.NODE_ENV !== \"production\") {\n      if (href.startsWith(\"//\")) warn$1(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);else if (!matchedRoute.matched.length) warn$1(`No match found for location with path \"${rawLocation.path != null ? rawLocation.path : rawLocation}\"`);\n    }\n    return assign({\n      fullPath,\n      hash,\n      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}\n    }, matchedRoute, {\n      redirectedFrom: void 0,\n      href\n    });\n  }\n  function locationAsObject(to) {\n    return typeof to === \"string\" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n  }\n  function checkCanceledNavigation(to, from) {\n    if (pendingLocation !== to) return createRouterError(ErrorTypes.NAVIGATION_CANCELLED, {\n      from,\n      to\n    });\n  }\n  function push(to) {\n    return pushWithRedirect(to);\n  }\n  function replace(to) {\n    return push(assign(locationAsObject(to), {\n      replace: true\n    }));\n  }\n  function handleRedirectRecord(to, from) {\n    const lastMatched = to.matched[to.matched.length - 1];\n    if (lastMatched && lastMatched.redirect) {\n      const {\n        redirect\n      } = lastMatched;\n      let newTargetLocation = typeof redirect === \"function\" ? redirect(to, from) : redirect;\n      if (typeof newTargetLocation === \"string\") {\n        newTargetLocation = newTargetLocation.includes(\"?\") || newTargetLocation.includes(\"#\") ? newTargetLocation = locationAsObject(newTargetLocation) : {\n          path: newTargetLocation\n        };\n        newTargetLocation.params = {};\n      }\n      if (process.env.NODE_ENV !== \"production\" && newTargetLocation.path == null && !(\"name\" in newTargetLocation)) {\n        warn$1(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n        throw new Error(\"Invalid redirect\");\n      }\n      return assign({\n        query: to.query,\n        hash: to.hash,\n        params: newTargetLocation.path != null ? {} : to.params\n      }, newTargetLocation);\n    }\n  }\n  function pushWithRedirect(to, redirectedFrom) {\n    const targetLocation = pendingLocation = resolve(to);\n    const from = currentRoute.value;\n    const data = to.state;\n    const force = to.force;\n    const replace = to.replace === true;\n    const shouldRedirect = handleRedirectRecord(targetLocation, from);\n    if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n      state: typeof shouldRedirect === \"object\" ? assign({}, data, shouldRedirect.state) : data,\n      force,\n      replace\n    }), redirectedFrom || targetLocation);\n    const toLocation = targetLocation;\n    toLocation.redirectedFrom = redirectedFrom;\n    let failure;\n    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n      failure = createRouterError(ErrorTypes.NAVIGATION_DUPLICATED, {\n        to: toLocation,\n        from\n      });\n      handleScroll(from, from, true, false);\n    }\n    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch(error => isNavigationFailure(error) ? isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then(failure => {\n      if (failure) {\n        if (isNavigationFailure(failure, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {\n          if (process.env.NODE_ENV !== \"production\" && isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 30) {\n            warn$1(`Detected a possibly infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow.\\n Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`);\n            return Promise.reject(/* @__PURE__ */new Error(\"Infinite redirect in navigation guard\"));\n          }\n          return pushWithRedirect(assign({\n            replace\n          }, locationAsObject(failure.to), {\n            state: typeof failure.to === \"object\" ? assign({}, data, failure.to.state) : data,\n            force\n          }), redirectedFrom || toLocation);\n        }\n      } else failure = finalizeNavigation(toLocation, from, true, replace, data);\n      triggerAfterEach(toLocation, from, failure);\n      return failure;\n    });\n  }\n  /**\n  * Helper to reject and skip all navigation guards if a new navigation happened\n  * @param to\n  * @param from\n  */\n  function checkCanceledNavigationAndReject(to, from) {\n    const error = checkCanceledNavigation(to, from);\n    return error ? Promise.reject(error) : Promise.resolve();\n  }\n  function runWithContext(fn) {\n    const app = installedApps.values().next().value;\n    return app && typeof app.runWithContext === \"function\" ? app.runWithContext(fn) : fn();\n  }\n  function navigate(to, from) {\n    let guards;\n    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n    guards = extractComponentsGuards(leavingRecords.reverse(), \"beforeRouteLeave\", to, from);\n    for (const record of leavingRecords) record.leaveGuards.forEach(guard => {\n      guards.push(guardToPromiseFn(guard, to, from));\n    });\n    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n    guards.push(canceledNavigationCheck);\n    return runGuardQueue(guards).then(() => {\n      guards = [];\n      for (const guard of beforeGuards.list()) guards.push(guardToPromiseFn(guard, to, from));\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = extractComponentsGuards(updatingRecords, \"beforeRouteUpdate\", to, from);\n      for (const record of updatingRecords) record.updateGuards.forEach(guard => {\n        guards.push(guardToPromiseFn(guard, to, from));\n      });\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = [];\n      for (const record of enteringRecords) if (record.beforeEnter) if (isArray(record.beforeEnter)) for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));else guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      to.matched.forEach(record => record.enterCallbacks = {});\n      guards = extractComponentsGuards(enteringRecords, \"beforeRouteEnter\", to, from, runWithContext);\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = [];\n      for (const guard of beforeResolveGuards.list()) guards.push(guardToPromiseFn(guard, to, from));\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).catch(err => isNavigationFailure(err, ErrorTypes.NAVIGATION_CANCELLED) ? err : Promise.reject(err));\n  }\n  function triggerAfterEach(to, from, failure) {\n    afterGuards.list().forEach(guard => runWithContext(() => guard(to, from, failure)));\n  }\n  /**\n  * - Cleans up any navigation guards\n  * - Changes the url if necessary\n  * - Calls the scrollBehavior\n  */\n  function finalizeNavigation(toLocation, from, isPush, replace, data) {\n    const error = checkCanceledNavigation(toLocation, from);\n    if (error) return error;\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n    const state = !isBrowser ? {} : history.state;\n    if (isPush) if (replace || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({\n      scroll: isFirstNavigation && state && state.scroll\n    }, data));else routerHistory.push(toLocation.fullPath, data);\n    currentRoute.value = toLocation;\n    handleScroll(toLocation, from, isPush, isFirstNavigation);\n    markAsReady();\n  }\n  let removeHistoryListener;\n  function setupListeners() {\n    if (removeHistoryListener) return;\n    removeHistoryListener = routerHistory.listen((to, _from, info) => {\n      if (!router.listening) return;\n      const toLocation = resolve(to);\n      const shouldRedirect = handleRedirectRecord(toLocation, router.currentRoute.value);\n      if (shouldRedirect) {\n        pushWithRedirect(assign(shouldRedirect, {\n          replace: true,\n          force: true\n        }), toLocation).catch(noop);\n        return;\n      }\n      pendingLocation = toLocation;\n      const from = currentRoute.value;\n      if (isBrowser) saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n      navigate(toLocation, from).catch(error => {\n        if (isNavigationFailure(error, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_CANCELLED)) return error;\n        if (isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {\n          pushWithRedirect(assign(locationAsObject(error.to), {\n            force: true\n          }), toLocation).then(failure => {\n            if (isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED) && !info.delta && info.type === NavigationType.pop) routerHistory.go(-1, false);\n          }).catch(noop);\n          return Promise.reject();\n        }\n        if (info.delta) routerHistory.go(-info.delta, false);\n        return triggerError(error, toLocation, from);\n      }).then(failure => {\n        failure = failure || finalizeNavigation(toLocation, from, false);\n        if (failure) {\n          if (info.delta && !isNavigationFailure(failure, ErrorTypes.NAVIGATION_CANCELLED)) routerHistory.go(-info.delta, false);else if (info.type === NavigationType.pop && isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED)) routerHistory.go(-1, false);\n        }\n        triggerAfterEach(toLocation, from, failure);\n      }).catch(noop);\n    });\n  }\n  let readyHandlers = useCallbacks();\n  let errorListeners = useCallbacks();\n  let ready;\n  /**\n  * Trigger errorListeners added via onError and throws the error as well\n  *\n  * @param error - error to throw\n  * @param to - location we were navigating to when the error happened\n  * @param from - location we were navigating from when the error happened\n  * @returns the error as a rejected promise\n  */\n  function triggerError(error, to, from) {\n    markAsReady(error);\n    const list = errorListeners.list();\n    if (list.length) list.forEach(handler => handler(error, to, from));else {\n      if (process.env.NODE_ENV !== \"production\") warn$1(\"uncaught error during route navigation:\");\n      console.error(error);\n    }\n    return Promise.reject(error);\n  }\n  function isReady() {\n    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();\n    return new Promise((resolve, reject) => {\n      readyHandlers.add([resolve, reject]);\n    });\n  }\n  function markAsReady(err) {\n    if (!ready) {\n      ready = !err;\n      setupListeners();\n      readyHandlers.list().forEach(([resolve, reject]) => err ? reject(err) : resolve());\n      readyHandlers.reset();\n    }\n    return err;\n  }\n  function handleScroll(to, from, isPush, isFirstNavigation) {\n    const {\n      scrollBehavior\n    } = options;\n    if (!isBrowser || !scrollBehavior) return Promise.resolve();\n    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then(position => position && scrollToPosition(position)).catch(err => triggerError(err, to, from));\n  }\n  const go = delta => routerHistory.go(delta);\n  let started;\n  const installedApps = /* @__PURE__ */new Set();\n  const router = {\n    currentRoute,\n    listening: true,\n    addRoute,\n    removeRoute,\n    clearRoutes: matcher.clearRoutes,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n    push,\n    replace,\n    go,\n    back: () => go(-1),\n    forward: () => go(1),\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n    onError: errorListeners.add,\n    isReady,\n    install(app) {\n      app.component(\"RouterLink\", RouterLink);\n      app.component(\"RouterView\", RouterView);\n      app.config.globalProperties.$router = router;\n      Object.defineProperty(app.config.globalProperties, \"$route\", {\n        enumerable: true,\n        get: () => unref(currentRoute)\n      });\n      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n        started = true;\n        push(routerHistory.location).catch(err => {\n          if (process.env.NODE_ENV !== \"production\") warn$1(\"Unexpected error when starting the router:\", err);\n        });\n      }\n      const reactiveRoute = {};\n      for (const key in START_LOCATION_NORMALIZED) Object.defineProperty(reactiveRoute, key, {\n        get: () => currentRoute.value[key],\n        enumerable: true\n      });\n      app.provide(routerKey, router);\n      app.provide(routeLocationKey, shallowReactive(reactiveRoute));\n      app.provide(routerViewLocationKey, currentRoute);\n      const unmountApp = app.unmount;\n      installedApps.add(app);\n      app.unmount = function () {\n        installedApps.delete(app);\n        if (installedApps.size < 1) {\n          pendingLocation = START_LOCATION_NORMALIZED;\n          removeHistoryListener && removeHistoryListener();\n          removeHistoryListener = null;\n          currentRoute.value = START_LOCATION_NORMALIZED;\n          started = false;\n          ready = false;\n        }\n        unmountApp();\n      };\n      if ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser && true) addDevtools(app, router, matcher);\n    }\n  };\n  function runGuardQueue(guards) {\n    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());\n  }\n  return router;\n}\n\n//#endregion\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, loadRouteLocation, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };","map":{"version":3,"names":["a","routerKey","b","isBrowser","c","ErrorTypes","d","isNavigationFailure","f","applyToParams","h","isArray","i","routeLocationKey","l","NavigationFailureType","n","useRouter","o","routerViewLocationKey","p","assign","r","matchedRouteKey","s","viewDepthKey","t","useRoute","u","createRouterError","v","mergeOptions","y","noop","C","normalizeBase","D","isSameRouteLocationParams","E","isSameRouteLocation","F","encodeParam","L","warn$1","M","stripBase","N","decode","O","isSameRouteRecord","P","encodeHash","S","createHref","T","START_LOCATION_NORMALIZED","_","saveScrollPosition","loadRouteLocation","NavigationType","useCallbacks","stringifyQuery","isRouteLocation","g","getScrollKey","getSavedScrollPosition","guardToPromiseFn","j","stringifyURL","k","parseURL","normalizeQuery","m","computeScrollPosition","extractChangingRecords","onBeforeRouteLeave","isRouteName","extractComponentsGuards","onBeforeRouteUpdate","addDevtools","parseQuery","scrollToPosition","x","START","NavigationDirection","computed","defineComponent","getCurrentInstance","inject","nextTick","provide","reactive","ref","shallowReactive","shallowRef","unref","watch","watchEffect","createBaseLocation","location","protocol","host","createCurrentLocation","base","pathname","search","hash","hashPos","indexOf","slicePos","includes","slice","length","pathFromHash","useHistoryListeners","historyState","currentLocation","replace","listeners","teardowns","pauseState","popStateHandler","state","to","from","value","fromState","delta","position","forEach","listener","type","pop","direction","forward","back","unknown","pauseListeners","listen","callback","push","teardown","index","splice","beforeUnloadListener","document","visibilityState","history","window","replaceState","scroll","destroy","removeEventListener","addEventListener","buildState","current","replaced","computeScroll","useHistoryStateNavigation","changeLocation","hashIndex","url","querySelector","err","process","env","NODE_ENV","console","error","data","currentState","createWebHistory","historyNavigation","historyListeners","go","triggerListeners","routerHistory","bind","Object","defineProperty","enumerable","get","createMemoryHistory","queue","setLocation","info","shouldTrigger","Math","max","min","createWebHashHistory","endsWith","TokenType","TokenizerState","ROOT_TOKEN","Static","VALID_PARAM_RE","tokenizePath","path","startsWith","Error","crash","message","buffer","previousState","tokens","segment","finalizeSegment","char","customRe","consumeBuffer","Param","ParamRegExp","ParamRegExpEnd","regexp","repeatable","optional","addCharToBuffer","EscapeNext","test","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","sensitive","strict","start","end","PathScore","REGEX_CHARS_RE","tokensToParser","segments","extraOptions","options","score","pattern","keys","segmentScores","Root","tokenIndex","token","subSegmentScore","Segment","BonusCaseSensitive","name","re","BonusCustomRegExp","RegExp","subPattern","Dynamic","BonusOptional","BonusRepeatable","BonusWildcard","BonusStrict","parse","match","params","key","split","stringify","avoidDuplicatedSlash","param","text","join","compareScoreArray","diff","comparePathParserScore","aScore","bScore","comp","abs","isLastScoreNegative","last","PATH_PARSER_OPTIONS_DEFAULTS","createRouteRecordMatcher","record","parent","parser","existingKeys","Set","has","add","matcher","children","alias","aliasOf","createRouterMatcher","routes","globalOptions","matchers","matcherMap","Map","getRecordMatcher","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","normalizeRouteRecord","checkChildMissingNameWithEmptyPath","normalizedRecords","aliases","components","originalMatcher","normalizedRecord","parentPath","connectingSlash","checkMissingParamsInAbsolutePath","checkSameParams","isAliasRecord","checkSameNameAsAncestor","removeRoute","isMatchable","insertMatcher","matcherRef","delete","getRoutes","findInsertionIndex","set","resolve","MATCHER_NOT_FOUND","invalidParams","filter","paramName","find","pickParams","concat","map","matched","parentMatcher","unshift","meta","mergeMetaFields","route","clearRoutes","clear","newParams","normalized","redirect","beforeEnter","props","normalizeRecordProps","instances","leaveGuards","updateGuards","enterCallbacks","component","default","propsObject","reduce","isSameParam","String","ancestor","lower","upper","mid","insertionAncestor","getInsertionAncestor","lastIndexOf","useLink","router","currentRoute","hasPrevious","previousTo","activeRecordIndex","routeMatched","currentMatched","findIndex","parentRecordPath","getOriginalPath","isActive","includesParams","isExactActive","navigate","e","guardEvent","catch","viewTransition","startViewTransition","Promise","__VUE_PROD_DEVTOOLS__","instance","linkContextDevtools","__vrl_devtools","flush","href","preferSingleVNode","vnodes","RouterLinkImpl","compatConfig","MODE","required","Boolean","activeClass","exactActiveClass","custom","ariaCurrentValue","setup","slots","link","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","onClick","class","RouterLink","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","currentTarget","getAttribute","target","preventDefault","outer","inner","innerValue","outerValue","some","valueOf","propClass","globalClass","defaultClass","RouterViewImpl","inheritAttrs","attrs","warnDeprecatedUsage","injectedRoute","routeToDisplay","injectedDepth","depth","initialDepth","matchedRoute","matchedRouteRef","viewRef","oldInstance","oldName","size","currentName","ViewComponent","normalizeSlot","Component","routePropsOption","routeProps","onVnodeUnmounted","vnode","isUnmounted","__vrv_devtools","slot","slotContent","RouterView","parentName","parentSubTreeType","subTree","createRouter","parseQuery$1","stringifyQuery$1","beforeGuards","beforeResolveGuards","afterGuards","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","paramValue","encodeParams","decodeParams","parentOrRoute","recordMatcher","routeMatcher","hasRoute","rawLocation","locationNormalized","fullPath","redirectedFrom","matcherLocation","targetParams","query","locationAsObject","checkCanceledNavigation","NAVIGATION_CANCELLED","pushWithRedirect","handleRedirectRecord","lastMatched","newTargetLocation","JSON","targetLocation","force","shouldRedirect","toLocation","failure","NAVIGATION_DUPLICATED","handleScroll","NAVIGATION_GUARD_REDIRECT","markAsReady","triggerError","then","_count","reject","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","runWithContext","fn","app","installedApps","values","next","guards","leavingRecords","updatingRecords","enteringRecords","reverse","guard","canceledNavigationCheck","runGuardQueue","list","isPush","isFirstNavigation","removeHistoryListener","setupListeners","_from","listening","NAVIGATION_ABORTED","readyHandlers","errorListeners","ready","handler","isReady","reset","scrollPosition","started","beforeEach","beforeResolve","afterEach","onError","install","config","globalProperties","$router","reactiveRoute","unmountApp","unmount","promise","START_LOCATION"],"sources":["F:/programming/medical-consultant/frontend/node_modules/vue-router/dist/vue-router.mjs"],"sourcesContent":["/*!\n * vue-router v5.0.2\n * (c) 2026 Eduardo San Martin Morote\n * @license MIT\n */\nimport { a as routerKey, b as isBrowser, c as ErrorTypes, d as isNavigationFailure, f as applyToParams, h as isArray, i as routeLocationKey, l as NavigationFailureType, n as useRouter, o as routerViewLocationKey, p as assign, r as matchedRouteKey, s as viewDepthKey, t as useRoute, u as createRouterError, v as mergeOptions, y as noop } from \"./useApi-o-nPpLEi.mjs\";\nimport { C as normalizeBase, D as isSameRouteLocationParams, E as isSameRouteLocation, F as encodeParam, L as warn$1, M as stripBase, N as decode, O as isSameRouteRecord, P as encodeHash, S as createHref, T as START_LOCATION_NORMALIZED, _ as saveScrollPosition, a as loadRouteLocation, b as NavigationType, c as useCallbacks, d as stringifyQuery, f as isRouteLocation, g as getScrollKey, h as getSavedScrollPosition, i as guardToPromiseFn, j as stringifyURL, k as parseURL, l as normalizeQuery, m as computeScrollPosition, n as extractChangingRecords, o as onBeforeRouteLeave, p as isRouteName, r as extractComponentsGuards, s as onBeforeRouteUpdate, t as addDevtools, u as parseQuery, v as scrollToPosition, x as START, y as NavigationDirection } from \"./devtools-CQC1vVRY.mjs\";\nimport { computed, defineComponent, getCurrentInstance, h, inject, nextTick, provide, reactive, ref, shallowReactive, shallowRef, unref, watch, watchEffect } from \"vue\";\n\n//#region src/history/html5.ts\nlet createBaseLocation = () => location.protocol + \"//\" + location.host;\n/**\n* Creates a normalized history location from a window.location object\n* @param base - The base path\n* @param location - The window.location object\n*/\nfunction createCurrentLocation(base, location) {\n\tconst { pathname, search, hash } = location;\n\tconst hashPos = base.indexOf(\"#\");\n\tif (hashPos > -1) {\n\t\tlet slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n\t\tlet pathFromHash = hash.slice(slicePos);\n\t\tif (pathFromHash[0] !== \"/\") pathFromHash = \"/\" + pathFromHash;\n\t\treturn stripBase(pathFromHash, \"\");\n\t}\n\treturn stripBase(pathname, base) + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n\tlet listeners = [];\n\tlet teardowns = [];\n\tlet pauseState = null;\n\tconst popStateHandler = ({ state }) => {\n\t\tconst to = createCurrentLocation(base, location);\n\t\tconst from = currentLocation.value;\n\t\tconst fromState = historyState.value;\n\t\tlet delta = 0;\n\t\tif (state) {\n\t\t\tcurrentLocation.value = to;\n\t\t\thistoryState.value = state;\n\t\t\tif (pauseState && pauseState === from) {\n\t\t\t\tpauseState = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdelta = fromState ? state.position - fromState.position : 0;\n\t\t} else replace(to);\n\t\tlisteners.forEach((listener) => {\n\t\t\tlistener(currentLocation.value, from, {\n\t\t\t\tdelta,\n\t\t\t\ttype: NavigationType.pop,\n\t\t\t\tdirection: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n\t\t\t});\n\t\t});\n\t};\n\tfunction pauseListeners() {\n\t\tpauseState = currentLocation.value;\n\t}\n\tfunction listen(callback) {\n\t\tlisteners.push(callback);\n\t\tconst teardown = () => {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index > -1) listeners.splice(index, 1);\n\t\t};\n\t\tteardowns.push(teardown);\n\t\treturn teardown;\n\t}\n\tfunction beforeUnloadListener() {\n\t\tif (document.visibilityState === \"hidden\") {\n\t\t\tconst { history } = window;\n\t\t\tif (!history.state) return;\n\t\t\thistory.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), \"\");\n\t\t}\n\t}\n\tfunction destroy() {\n\t\tfor (const teardown of teardowns) teardown();\n\t\tteardowns = [];\n\t\twindow.removeEventListener(\"popstate\", popStateHandler);\n\t\twindow.removeEventListener(\"pagehide\", beforeUnloadListener);\n\t\tdocument.removeEventListener(\"visibilitychange\", beforeUnloadListener);\n\t}\n\twindow.addEventListener(\"popstate\", popStateHandler);\n\twindow.addEventListener(\"pagehide\", beforeUnloadListener);\n\tdocument.addEventListener(\"visibilitychange\", beforeUnloadListener);\n\treturn {\n\t\tpauseListeners,\n\t\tlisten,\n\t\tdestroy\n\t};\n}\n/**\n* Creates a state object\n*/\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n\treturn {\n\t\tback,\n\t\tcurrent,\n\t\tforward,\n\t\treplaced,\n\t\tposition: window.history.length,\n\t\tscroll: computeScroll ? computeScrollPosition() : null\n\t};\n}\nfunction useHistoryStateNavigation(base) {\n\tconst { history, location } = window;\n\tconst currentLocation = { value: createCurrentLocation(base, location) };\n\tconst historyState = { value: history.state };\n\tif (!historyState.value) changeLocation(currentLocation.value, {\n\t\tback: null,\n\t\tcurrent: currentLocation.value,\n\t\tforward: null,\n\t\tposition: history.length - 1,\n\t\treplaced: true,\n\t\tscroll: null\n\t}, true);\n\tfunction changeLocation(to, state, replace) {\n\t\t/**\n\t\t* if a base tag is provided, and we are on a normal domain, we have to\n\t\t* respect the provided `base` attribute because pushState() will use it and\n\t\t* potentially erase anything before the `#` like at\n\t\t* https://github.com/vuejs/router/issues/685 where a base of\n\t\t* `/folder/#` but a base of `/` would erase the `/folder/` section. If\n\t\t* there is no host, the `<base>` tag makes no sense and if there isn't a\n\t\t* base tag we can just use everything after the `#`.\n\t\t*/\n\t\tconst hashIndex = base.indexOf(\"#\");\n\t\tconst url = hashIndex > -1 ? (location.host && document.querySelector(\"base\") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n\t\ttry {\n\t\t\thistory[replace ? \"replaceState\" : \"pushState\"](state, \"\", url);\n\t\t\thistoryState.value = state;\n\t\t} catch (err) {\n\t\t\tif (process.env.NODE_ENV !== \"production\") warn$1(\"Error with push/replace State\", err);\n\t\t\telse console.error(err);\n\t\t\tlocation[replace ? \"replace\" : \"assign\"](url);\n\t\t}\n\t}\n\tfunction replace(to, data) {\n\t\tchangeLocation(to, assign({}, history.state, buildState(historyState.value.back, to, historyState.value.forward, true), data, { position: historyState.value.position }), true);\n\t\tcurrentLocation.value = to;\n\t}\n\tfunction push(to, data) {\n\t\tconst currentState = assign({}, historyState.value, history.state, {\n\t\t\tforward: to,\n\t\t\tscroll: computeScrollPosition()\n\t\t});\n\t\tif (process.env.NODE_ENV !== \"production\" && !history.state) warn$1(\"history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\nhistory.replaceState(history.state, '', url)\\n\\nYou can find more information at https://router.vuejs.org/guide/migration/#Usage-of-history-state\");\n\t\tchangeLocation(currentState.current, currentState, true);\n\t\tchangeLocation(to, assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data), false);\n\t\tcurrentLocation.value = to;\n\t}\n\treturn {\n\t\tlocation: currentLocation,\n\t\tstate: historyState,\n\t\tpush,\n\t\treplace\n\t};\n}\n/**\n* Creates an HTML5 history. Most common history for single page applications.\n*\n* @param base -\n*/\nfunction createWebHistory(base) {\n\tbase = normalizeBase(base);\n\tconst historyNavigation = useHistoryStateNavigation(base);\n\tconst historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n\tfunction go(delta, triggerListeners = true) {\n\t\tif (!triggerListeners) historyListeners.pauseListeners();\n\t\thistory.go(delta);\n\t}\n\tconst routerHistory = assign({\n\t\tlocation: \"\",\n\t\tbase,\n\t\tgo,\n\t\tcreateHref: createHref.bind(null, base)\n\t}, historyNavigation, historyListeners);\n\tObject.defineProperty(routerHistory, \"location\", {\n\t\tenumerable: true,\n\t\tget: () => historyNavigation.location.value\n\t});\n\tObject.defineProperty(routerHistory, \"state\", {\n\t\tenumerable: true,\n\t\tget: () => historyNavigation.state.value\n\t});\n\treturn routerHistory;\n}\n\n//#endregion\n//#region src/history/memory.ts\n/**\n* Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\n* It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\n*\n* @param base - Base applied to all urls, defaults to '/'\n* @returns a history object that can be passed to the router constructor\n*/\nfunction createMemoryHistory(base = \"\") {\n\tlet listeners = [];\n\tlet queue = [[START, {}]];\n\tlet position = 0;\n\tbase = normalizeBase(base);\n\tfunction setLocation(location, state = {}) {\n\t\tposition++;\n\t\tif (position !== queue.length) queue.splice(position);\n\t\tqueue.push([location, state]);\n\t}\n\tfunction triggerListeners(to, from, { direction, delta }) {\n\t\tconst info = {\n\t\t\tdirection,\n\t\t\tdelta,\n\t\t\ttype: NavigationType.pop\n\t\t};\n\t\tfor (const callback of listeners) callback(to, from, info);\n\t}\n\tconst routerHistory = {\n\t\tlocation: START,\n\t\tstate: {},\n\t\tbase,\n\t\tcreateHref: createHref.bind(null, base),\n\t\treplace(to, state) {\n\t\t\tqueue.splice(position--, 1);\n\t\t\tsetLocation(to, state);\n\t\t},\n\t\tpush(to, state) {\n\t\t\tsetLocation(to, state);\n\t\t},\n\t\tlisten(callback) {\n\t\t\tlisteners.push(callback);\n\t\t\treturn () => {\n\t\t\t\tconst index = listeners.indexOf(callback);\n\t\t\t\tif (index > -1) listeners.splice(index, 1);\n\t\t\t};\n\t\t},\n\t\tdestroy() {\n\t\t\tlisteners = [];\n\t\t\tqueue = [[START, {}]];\n\t\t\tposition = 0;\n\t\t},\n\t\tgo(delta, shouldTrigger = true) {\n\t\t\tconst from = this.location;\n\t\t\tconst direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n\t\t\tposition = Math.max(0, Math.min(position + delta, queue.length - 1));\n\t\t\tif (shouldTrigger) triggerListeners(this.location, from, {\n\t\t\t\tdirection,\n\t\t\t\tdelta\n\t\t\t});\n\t\t}\n\t};\n\tObject.defineProperty(routerHistory, \"location\", {\n\t\tenumerable: true,\n\t\tget: () => queue[position][0]\n\t});\n\tObject.defineProperty(routerHistory, \"state\", {\n\t\tenumerable: true,\n\t\tget: () => queue[position][1]\n\t});\n\treturn routerHistory;\n}\n\n//#endregion\n//#region src/history/hash.ts\n/**\n* Creates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to\n* handle any URL is not possible.\n*\n* @param base - optional base to provide. Defaults to `location.pathname + location.search` If there is a `<base>` tag\n* in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState()\n* calls**, meaning that if you use a `<base>` tag, it's `href` value **has to match this parameter** (ignoring anything\n* after the `#`).\n*\n* @example\n* ```js\n* // at https://example.com/folder\n* createWebHashHistory() // gives a url of `https://example.com/folder#`\n* createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n* // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n* createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n* // you should avoid doing this because it changes the original url and breaks copying urls\n* createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n*\n* // at file:///usr/etc/folder/index.html\n* // for locations with no `host`, the base is ignored\n* createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n* ```\n*/\nfunction createWebHashHistory(base) {\n\tbase = location.host ? base || location.pathname + location.search : \"\";\n\tif (!base.includes(\"#\")) base += \"#\";\n\tif (process.env.NODE_ENV !== \"production\" && !base.endsWith(\"#/\") && !base.endsWith(\"#\")) warn$1(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, \"#\")}\".`);\n\treturn createWebHistory(base);\n}\n\n//#endregion\n//#region src/matcher/pathTokenizer.ts\nlet TokenType = /* @__PURE__ */ function(TokenType) {\n\tTokenType[TokenType[\"Static\"] = 0] = \"Static\";\n\tTokenType[TokenType[\"Param\"] = 1] = \"Param\";\n\tTokenType[TokenType[\"Group\"] = 2] = \"Group\";\n\treturn TokenType;\n}({});\nvar TokenizerState = /* @__PURE__ */ function(TokenizerState) {\n\tTokenizerState[TokenizerState[\"Static\"] = 0] = \"Static\";\n\tTokenizerState[TokenizerState[\"Param\"] = 1] = \"Param\";\n\tTokenizerState[TokenizerState[\"ParamRegExp\"] = 2] = \"ParamRegExp\";\n\tTokenizerState[TokenizerState[\"ParamRegExpEnd\"] = 3] = \"ParamRegExpEnd\";\n\tTokenizerState[TokenizerState[\"EscapeNext\"] = 4] = \"EscapeNext\";\n\treturn TokenizerState;\n}(TokenizerState || {});\nconst ROOT_TOKEN = {\n\ttype: TokenType.Static,\n\tvalue: \"\"\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\nfunction tokenizePath(path) {\n\tif (!path) return [[]];\n\tif (path === \"/\") return [[ROOT_TOKEN]];\n\tif (!path.startsWith(\"/\")) throw new Error(process.env.NODE_ENV !== \"production\" ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".` : `Invalid path \"${path}\"`);\n\tfunction crash(message) {\n\t\tthrow new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n\t}\n\tlet state = TokenizerState.Static;\n\tlet previousState = state;\n\tconst tokens = [];\n\tlet segment;\n\tfunction finalizeSegment() {\n\t\tif (segment) tokens.push(segment);\n\t\tsegment = [];\n\t}\n\tlet i = 0;\n\tlet char;\n\tlet buffer = \"\";\n\tlet customRe = \"\";\n\tfunction consumeBuffer() {\n\t\tif (!buffer) return;\n\t\tif (state === TokenizerState.Static) segment.push({\n\t\t\ttype: TokenType.Static,\n\t\t\tvalue: buffer\n\t\t});\n\t\telse if (state === TokenizerState.Param || state === TokenizerState.ParamRegExp || state === TokenizerState.ParamRegExpEnd) {\n\t\t\tif (segment.length > 1 && (char === \"*\" || char === \"+\")) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n\t\t\tsegment.push({\n\t\t\t\ttype: TokenType.Param,\n\t\t\t\tvalue: buffer,\n\t\t\t\tregexp: customRe,\n\t\t\t\trepeatable: char === \"*\" || char === \"+\",\n\t\t\t\toptional: char === \"*\" || char === \"?\"\n\t\t\t});\n\t\t} else crash(\"Invalid state to consume buffer\");\n\t\tbuffer = \"\";\n\t}\n\tfunction addCharToBuffer() {\n\t\tbuffer += char;\n\t}\n\twhile (i < path.length) {\n\t\tchar = path[i++];\n\t\tif (char === \"\\\\\" && state !== TokenizerState.ParamRegExp) {\n\t\t\tpreviousState = state;\n\t\t\tstate = TokenizerState.EscapeNext;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (state) {\n\t\t\tcase TokenizerState.Static:\n\t\t\t\tif (char === \"/\") {\n\t\t\t\t\tif (buffer) consumeBuffer();\n\t\t\t\t\tfinalizeSegment();\n\t\t\t\t} else if (char === \":\") {\n\t\t\t\t\tconsumeBuffer();\n\t\t\t\t\tstate = TokenizerState.Param;\n\t\t\t\t} else addCharToBuffer();\n\t\t\t\tbreak;\n\t\t\tcase TokenizerState.EscapeNext:\n\t\t\t\taddCharToBuffer();\n\t\t\t\tstate = previousState;\n\t\t\t\tbreak;\n\t\t\tcase TokenizerState.Param:\n\t\t\t\tif (char === \"(\") state = TokenizerState.ParamRegExp;\n\t\t\t\telse if (VALID_PARAM_RE.test(char)) addCharToBuffer();\n\t\t\t\telse {\n\t\t\t\t\tconsumeBuffer();\n\t\t\t\t\tstate = TokenizerState.Static;\n\t\t\t\t\tif (char !== \"*\" && char !== \"?\" && char !== \"+\") i--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TokenizerState.ParamRegExp:\n\t\t\t\tif (char === \")\") if (customRe[customRe.length - 1] == \"\\\\\") customRe = customRe.slice(0, -1) + char;\n\t\t\t\telse state = TokenizerState.ParamRegExpEnd;\n\t\t\t\telse customRe += char;\n\t\t\t\tbreak;\n\t\t\tcase TokenizerState.ParamRegExpEnd:\n\t\t\t\tconsumeBuffer();\n\t\t\t\tstate = TokenizerState.Static;\n\t\t\t\tif (char !== \"*\" && char !== \"?\" && char !== \"+\") i--;\n\t\t\t\tcustomRe = \"\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcrash(\"Unknown state\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (state === TokenizerState.ParamRegExp) crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n\tconsumeBuffer();\n\tfinalizeSegment();\n\treturn tokens;\n}\n\n//#endregion\n//#region src/matcher/pathParserRanker.ts\nconst BASE_PARAM_PATTERN = \"[^/]+?\";\nconst BASE_PATH_PARSER_OPTIONS = {\n\tsensitive: false,\n\tstrict: false,\n\tstart: true,\n\tend: true\n};\nvar PathScore = /* @__PURE__ */ function(PathScore) {\n\tPathScore[PathScore[\"_multiplier\"] = 10] = \"_multiplier\";\n\tPathScore[PathScore[\"Root\"] = 90] = \"Root\";\n\tPathScore[PathScore[\"Segment\"] = 40] = \"Segment\";\n\tPathScore[PathScore[\"SubSegment\"] = 30] = \"SubSegment\";\n\tPathScore[PathScore[\"Static\"] = 40] = \"Static\";\n\tPathScore[PathScore[\"Dynamic\"] = 20] = \"Dynamic\";\n\tPathScore[PathScore[\"BonusCustomRegExp\"] = 10] = \"BonusCustomRegExp\";\n\tPathScore[PathScore[\"BonusWildcard\"] = -50] = \"BonusWildcard\";\n\tPathScore[PathScore[\"BonusRepeatable\"] = -20] = \"BonusRepeatable\";\n\tPathScore[PathScore[\"BonusOptional\"] = -8] = \"BonusOptional\";\n\tPathScore[PathScore[\"BonusStrict\"] = .7000000000000001] = \"BonusStrict\";\n\tPathScore[PathScore[\"BonusCaseSensitive\"] = .25] = \"BonusCaseSensitive\";\n\treturn PathScore;\n}(PathScore || {});\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\n* Creates a path parser from an array of Segments (a segment is an array of Tokens)\n*\n* @param segments - array of segments returned by tokenizePath\n* @param extraOptions - optional options for the regexp\n* @returns a PathParser\n*/\nfunction tokensToParser(segments, extraOptions) {\n\tconst options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n\tconst score = [];\n\tlet pattern = options.start ? \"^\" : \"\";\n\tconst keys = [];\n\tfor (const segment of segments) {\n\t\tconst segmentScores = segment.length ? [] : [PathScore.Root];\n\t\tif (options.strict && !segment.length) pattern += \"/\";\n\t\tfor (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n\t\t\tconst token = segment[tokenIndex];\n\t\t\tlet subSegmentScore = PathScore.Segment + (options.sensitive ? PathScore.BonusCaseSensitive : 0);\n\t\t\tif (token.type === TokenType.Static) {\n\t\t\t\tif (!tokenIndex) pattern += \"/\";\n\t\t\t\tpattern += token.value.replace(REGEX_CHARS_RE, \"\\\\$&\");\n\t\t\t\tsubSegmentScore += PathScore.Static;\n\t\t\t} else if (token.type === TokenType.Param) {\n\t\t\t\tconst { value, repeatable, optional, regexp } = token;\n\t\t\t\tkeys.push({\n\t\t\t\t\tname: value,\n\t\t\t\t\trepeatable,\n\t\t\t\t\toptional\n\t\t\t\t});\n\t\t\t\tconst re = regexp ? regexp : BASE_PARAM_PATTERN;\n\t\t\t\tif (re !== BASE_PARAM_PATTERN) {\n\t\t\t\t\tsubSegmentScore += PathScore.BonusCustomRegExp;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnew RegExp(`(${re})`);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tthrow new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` + err.message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\n\t\t\t\tif (!tokenIndex) subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : \"/\" + subPattern;\n\t\t\t\tif (optional) subPattern += \"?\";\n\t\t\t\tpattern += subPattern;\n\t\t\t\tsubSegmentScore += PathScore.Dynamic;\n\t\t\t\tif (optional) subSegmentScore += PathScore.BonusOptional;\n\t\t\t\tif (repeatable) subSegmentScore += PathScore.BonusRepeatable;\n\t\t\t\tif (re === \".*\") subSegmentScore += PathScore.BonusWildcard;\n\t\t\t}\n\t\t\tsegmentScores.push(subSegmentScore);\n\t\t}\n\t\tscore.push(segmentScores);\n\t}\n\tif (options.strict && options.end) {\n\t\tconst i = score.length - 1;\n\t\tscore[i][score[i].length - 1] += PathScore.BonusStrict;\n\t}\n\tif (!options.strict) pattern += \"/?\";\n\tif (options.end) pattern += \"$\";\n\telse if (options.strict && !pattern.endsWith(\"/\")) pattern += \"(?:/|$)\";\n\tconst re = new RegExp(pattern, options.sensitive ? \"\" : \"i\");\n\tfunction parse(path) {\n\t\tconst match = path.match(re);\n\t\tconst params = {};\n\t\tif (!match) return null;\n\t\tfor (let i = 1; i < match.length; i++) {\n\t\t\tconst value = match[i] || \"\";\n\t\t\tconst key = keys[i - 1];\n\t\t\tparams[key.name] = value && key.repeatable ? value.split(\"/\") : value;\n\t\t}\n\t\treturn params;\n\t}\n\tfunction stringify(params) {\n\t\tlet path = \"\";\n\t\tlet avoidDuplicatedSlash = false;\n\t\tfor (const segment of segments) {\n\t\t\tif (!avoidDuplicatedSlash || !path.endsWith(\"/\")) path += \"/\";\n\t\t\tavoidDuplicatedSlash = false;\n\t\t\tfor (const token of segment) if (token.type === TokenType.Static) path += token.value;\n\t\t\telse if (token.type === TokenType.Param) {\n\t\t\t\tconst { value, repeatable, optional } = token;\n\t\t\t\tconst param = value in params ? params[value] : \"\";\n\t\t\t\tif (isArray(param) && !repeatable) throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n\t\t\t\tconst text = isArray(param) ? param.join(\"/\") : param;\n\t\t\t\tif (!text) if (optional) {\n\t\t\t\t\tif (segment.length < 2) if (path.endsWith(\"/\")) path = path.slice(0, -1);\n\t\t\t\t\telse avoidDuplicatedSlash = true;\n\t\t\t\t} else throw new Error(`Missing required param \"${value}\"`);\n\t\t\t\tpath += text;\n\t\t\t}\n\t\t}\n\t\treturn path || \"/\";\n\t}\n\treturn {\n\t\tre,\n\t\tscore,\n\t\tkeys,\n\t\tparse,\n\t\tstringify\n\t};\n}\n/**\n* Compares an array of numbers as used in PathParser.score and returns a\n* number. This function can be used to `sort` an array\n*\n* @param a - first array of numbers\n* @param b - second array of numbers\n* @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n* should be sorted first\n*/\nfunction compareScoreArray(a, b) {\n\tlet i = 0;\n\twhile (i < a.length && i < b.length) {\n\t\tconst diff = b[i] - a[i];\n\t\tif (diff) return diff;\n\t\ti++;\n\t}\n\tif (a.length < b.length) return a.length === 1 && a[0] === PathScore.Static + PathScore.Segment ? -1 : 1;\n\telse if (a.length > b.length) return b.length === 1 && b[0] === PathScore.Static + PathScore.Segment ? 1 : -1;\n\treturn 0;\n}\n/**\n* Compare function that can be used with `sort` to sort an array of PathParser\n*\n* @param a - first PathParser\n* @param b - second PathParser\n* @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n*/\nfunction comparePathParserScore(a, b) {\n\tlet i = 0;\n\tconst aScore = a.score;\n\tconst bScore = b.score;\n\twhile (i < aScore.length && i < bScore.length) {\n\t\tconst comp = compareScoreArray(aScore[i], bScore[i]);\n\t\tif (comp) return comp;\n\t\ti++;\n\t}\n\tif (Math.abs(bScore.length - aScore.length) === 1) {\n\t\tif (isLastScoreNegative(aScore)) return 1;\n\t\tif (isLastScoreNegative(bScore)) return -1;\n\t}\n\treturn bScore.length - aScore.length;\n}\n/**\n* This allows detecting splats at the end of a path: /home/:id(.*)*\n*\n* @param score - score to check\n* @returns true if the last entry is negative\n*/\nfunction isLastScoreNegative(score) {\n\tconst last = score[score.length - 1];\n\treturn score.length > 0 && last[last.length - 1] < 0;\n}\nconst PATH_PARSER_OPTIONS_DEFAULTS = {\n\tstrict: false,\n\tend: true,\n\tsensitive: false\n};\n\n//#endregion\n//#region src/matcher/pathMatcher.ts\nfunction createRouteRecordMatcher(record, parent, options) {\n\tconst parser = tokensToParser(tokenizePath(record.path), options);\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst existingKeys = /* @__PURE__ */ new Set();\n\t\tfor (const key of parser.keys) {\n\t\t\tif (existingKeys.has(key.name)) warn$1(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n\t\t\texistingKeys.add(key.name);\n\t\t}\n\t}\n\tconst matcher = assign(parser, {\n\t\trecord,\n\t\tparent,\n\t\tchildren: [],\n\t\talias: []\n\t});\n\tif (parent) {\n\t\tif (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);\n\t}\n\treturn matcher;\n}\n\n//#endregion\n//#region src/matcher/index.ts\n/**\n* Creates a Router Matcher.\n*\n* @internal\n* @param routes - array of initial routes\n* @param globalOptions - global route options\n*/\nfunction createRouterMatcher(routes, globalOptions) {\n\tconst matchers = [];\n\tconst matcherMap = /* @__PURE__ */ new Map();\n\tglobalOptions = mergeOptions(PATH_PARSER_OPTIONS_DEFAULTS, globalOptions);\n\tfunction getRecordMatcher(name) {\n\t\treturn matcherMap.get(name);\n\t}\n\tfunction addRoute(record, parent, originalRecord) {\n\t\tconst isRootAdd = !originalRecord;\n\t\tconst mainNormalizedRecord = normalizeRouteRecord(record);\n\t\tif (process.env.NODE_ENV !== \"production\") checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);\n\t\tmainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n\t\tconst options = mergeOptions(globalOptions, record);\n\t\tconst normalizedRecords = [mainNormalizedRecord];\n\t\tif (\"alias\" in record) {\n\t\t\tconst aliases = typeof record.alias === \"string\" ? [record.alias] : record.alias;\n\t\t\tfor (const alias of aliases) normalizedRecords.push(normalizeRouteRecord(assign({}, mainNormalizedRecord, {\n\t\t\t\tcomponents: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n\t\t\t\tpath: alias,\n\t\t\t\taliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord\n\t\t\t})));\n\t\t}\n\t\tlet matcher;\n\t\tlet originalMatcher;\n\t\tfor (const normalizedRecord of normalizedRecords) {\n\t\t\tconst { path } = normalizedRecord;\n\t\t\tif (parent && path[0] !== \"/\") {\n\t\t\t\tconst parentPath = parent.record.path;\n\t\t\t\tconst connectingSlash = parentPath[parentPath.length - 1] === \"/\" ? \"\" : \"/\";\n\t\t\t\tnormalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n\t\t\t}\n\t\t\tif (process.env.NODE_ENV !== \"production\" && normalizedRecord.path === \"*\") throw new Error(\"Catch all routes (\\\"*\\\") must now be defined using a param with a custom regexp.\\nSee more at https://router.vuejs.org/guide/migration/#Removed-star-or-catch-all-routes.\");\n\t\t\tmatcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n\t\t\tif (process.env.NODE_ENV !== \"production\" && parent && path[0] === \"/\") checkMissingParamsInAbsolutePath(matcher, parent);\n\t\t\tif (originalRecord) {\n\t\t\t\toriginalRecord.alias.push(matcher);\n\t\t\t\tif (process.env.NODE_ENV !== \"production\") checkSameParams(originalRecord, matcher);\n\t\t\t} else {\n\t\t\t\toriginalMatcher = originalMatcher || matcher;\n\t\t\t\tif (originalMatcher !== matcher) originalMatcher.alias.push(matcher);\n\t\t\t\tif (isRootAdd && record.name && !isAliasRecord(matcher)) {\n\t\t\t\t\tif (process.env.NODE_ENV !== \"production\") checkSameNameAsAncestor(record, parent);\n\t\t\t\t\tremoveRoute(record.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isMatchable(matcher)) insertMatcher(matcher);\n\t\t\tif (mainNormalizedRecord.children) {\n\t\t\t\tconst children = mainNormalizedRecord.children;\n\t\t\t\tfor (let i = 0; i < children.length; i++) addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n\t\t\t}\n\t\t\toriginalRecord = originalRecord || matcher;\n\t\t}\n\t\treturn originalMatcher ? () => {\n\t\t\tremoveRoute(originalMatcher);\n\t\t} : noop;\n\t}\n\tfunction removeRoute(matcherRef) {\n\t\tif (isRouteName(matcherRef)) {\n\t\t\tconst matcher = matcherMap.get(matcherRef);\n\t\t\tif (matcher) {\n\t\t\t\tmatcherMap.delete(matcherRef);\n\t\t\t\tmatchers.splice(matchers.indexOf(matcher), 1);\n\t\t\t\tmatcher.children.forEach(removeRoute);\n\t\t\t\tmatcher.alias.forEach(removeRoute);\n\t\t\t}\n\t\t} else {\n\t\t\tconst index = matchers.indexOf(matcherRef);\n\t\t\tif (index > -1) {\n\t\t\t\tmatchers.splice(index, 1);\n\t\t\t\tif (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);\n\t\t\t\tmatcherRef.children.forEach(removeRoute);\n\t\t\t\tmatcherRef.alias.forEach(removeRoute);\n\t\t\t}\n\t\t}\n\t}\n\tfunction getRoutes() {\n\t\treturn matchers;\n\t}\n\tfunction insertMatcher(matcher) {\n\t\tconst index = findInsertionIndex(matcher, matchers);\n\t\tmatchers.splice(index, 0, matcher);\n\t\tif (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);\n\t}\n\tfunction resolve(location, currentLocation) {\n\t\tlet matcher;\n\t\tlet params = {};\n\t\tlet path;\n\t\tlet name;\n\t\tif (\"name\" in location && location.name) {\n\t\t\tmatcher = matcherMap.get(location.name);\n\t\t\tif (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, { location });\n\t\t\tif (process.env.NODE_ENV !== \"production\") {\n\t\t\t\tconst invalidParams = Object.keys(location.params || {}).filter((paramName) => !matcher.keys.find((k) => k.name === paramName));\n\t\t\t\tif (invalidParams.length) warn$1(`Discarded invalid param(s) \"${invalidParams.join(\"\\\", \\\"\")}\" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);\n\t\t\t}\n\t\t\tname = matcher.record.name;\n\t\t\tparams = assign(pickParams(currentLocation.params, matcher.keys.filter((k) => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k) => k.optional) : []).map((k) => k.name)), location.params && pickParams(location.params, matcher.keys.map((k) => k.name)));\n\t\t\tpath = matcher.stringify(params);\n\t\t} else if (location.path != null) {\n\t\t\tpath = location.path;\n\t\t\tif (process.env.NODE_ENV !== \"production\" && !path.startsWith(\"/\")) warn$1(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`);\n\t\t\tmatcher = matchers.find((m) => m.re.test(path));\n\t\t\tif (matcher) {\n\t\t\t\tparams = matcher.parse(path);\n\t\t\t\tname = matcher.record.name;\n\t\t\t}\n\t\t} else {\n\t\t\tmatcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));\n\t\t\tif (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, {\n\t\t\t\tlocation,\n\t\t\t\tcurrentLocation\n\t\t\t});\n\t\t\tname = matcher.record.name;\n\t\t\tparams = assign({}, currentLocation.params, location.params);\n\t\t\tpath = matcher.stringify(params);\n\t\t}\n\t\tconst matched = [];\n\t\tlet parentMatcher = matcher;\n\t\twhile (parentMatcher) {\n\t\t\tmatched.unshift(parentMatcher.record);\n\t\t\tparentMatcher = parentMatcher.parent;\n\t\t}\n\t\treturn {\n\t\t\tname,\n\t\t\tpath,\n\t\t\tparams,\n\t\t\tmatched,\n\t\t\tmeta: mergeMetaFields(matched)\n\t\t};\n\t}\n\troutes.forEach((route) => addRoute(route));\n\tfunction clearRoutes() {\n\t\tmatchers.length = 0;\n\t\tmatcherMap.clear();\n\t}\n\treturn {\n\t\taddRoute,\n\t\tresolve,\n\t\tremoveRoute,\n\t\tclearRoutes,\n\t\tgetRoutes,\n\t\tgetRecordMatcher\n\t};\n}\n/**\n* Picks an object param to contain only specified keys.\n*\n* @param params - params object to pick from\n* @param keys - keys to pick\n*/\nfunction pickParams(params, keys) {\n\tconst newParams = {};\n\tfor (const key of keys) if (key in params) newParams[key] = params[key];\n\treturn newParams;\n}\n/**\n* Normalizes a RouteRecordRaw. Creates a copy\n*\n* @param record\n* @returns the normalized version\n*/\nfunction normalizeRouteRecord(record) {\n\tconst normalized = {\n\t\tpath: record.path,\n\t\tredirect: record.redirect,\n\t\tname: record.name,\n\t\tmeta: record.meta || {},\n\t\taliasOf: record.aliasOf,\n\t\tbeforeEnter: record.beforeEnter,\n\t\tprops: normalizeRecordProps(record),\n\t\tchildren: record.children || [],\n\t\tinstances: {},\n\t\tleaveGuards: /* @__PURE__ */ new Set(),\n\t\tupdateGuards: /* @__PURE__ */ new Set(),\n\t\tenterCallbacks: {},\n\t\tcomponents: \"components\" in record ? record.components || null : record.component && { default: record.component }\n\t};\n\tObject.defineProperty(normalized, \"mods\", { value: {} });\n\treturn normalized;\n}\n/**\n* Normalize the optional `props` in a record to always be an object similar to\n* components. Also accept a boolean for components.\n* @param record\n*/\nfunction normalizeRecordProps(record) {\n\tconst propsObject = {};\n\tconst props = record.props || false;\n\tif (\"component\" in record) propsObject.default = props;\n\telse for (const name in record.components) propsObject[name] = typeof props === \"object\" ? props[name] : props;\n\treturn propsObject;\n}\n/**\n* Checks if a record or any of its parent is an alias\n* @param record\n*/\nfunction isAliasRecord(record) {\n\twhile (record) {\n\t\tif (record.record.aliasOf) return true;\n\t\trecord = record.parent;\n\t}\n\treturn false;\n}\n/**\n* Merge meta fields of an array of records\n*\n* @param matched - array of matched records\n*/\nfunction mergeMetaFields(matched) {\n\treturn matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction isSameParam(a, b) {\n\treturn a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\n/**\n* Check if a path and its alias have the same required params\n*\n* @param a - original record\n* @param b - alias record\n*/\nfunction checkSameParams(a, b) {\n\tfor (const key of a.keys) if (!key.optional && !b.keys.find(isSameParam.bind(null, key))) return warn$1(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n\tfor (const key of b.keys) if (!key.optional && !a.keys.find(isSameParam.bind(null, key))) return warn$1(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n}\n/**\n* A route with a name and a child with an empty path without a name should warn when adding the route\n*\n* @param mainNormalizedRecord - RouteRecordNormalized\n* @param parent - RouteRecordMatcher\n*/\nfunction checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {\n\tif (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path && mainNormalizedRecord.children.length === 0) warn$1(`The route named \"${String(parent.record.name)}\" has a child without a name, an empty path, and no children. This is probably a mistake: using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to silence the warning.`);\n}\nfunction checkSameNameAsAncestor(record, parent) {\n\tfor (let ancestor = parent; ancestor; ancestor = ancestor.parent) if (ancestor.record.name === record.name) throw new Error(`A route named \"${String(record.name)}\" has been added as a ${parent === ancestor ? \"child\" : \"descendant\"} of a route with the same name. Route names must be unique and a nested route cannot use the same name as an ancestor.`);\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n\tfor (const key of parent.keys) if (!record.keys.find(isSameParam.bind(null, key))) return warn$1(`Absolute path \"${record.record.path}\" must have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n}\n/**\n* Performs a binary search to find the correct insertion index for a new matcher.\n*\n* Matchers are primarily sorted by their score. If scores are tied then we also consider parent/child relationships,\n* with descendants coming before ancestors. If there's still a tie, new routes are inserted after existing routes.\n*\n* @param matcher - new matcher to be inserted\n* @param matchers - existing matchers\n*/\nfunction findInsertionIndex(matcher, matchers) {\n\tlet lower = 0;\n\tlet upper = matchers.length;\n\twhile (lower !== upper) {\n\t\tconst mid = lower + upper >> 1;\n\t\tif (comparePathParserScore(matcher, matchers[mid]) < 0) upper = mid;\n\t\telse lower = mid + 1;\n\t}\n\tconst insertionAncestor = getInsertionAncestor(matcher);\n\tif (insertionAncestor) {\n\t\tupper = matchers.lastIndexOf(insertionAncestor, upper - 1);\n\t\tif (process.env.NODE_ENV !== \"production\" && upper < 0) warn$1(`Finding ancestor route \"${insertionAncestor.record.path}\" failed for \"${matcher.record.path}\"`);\n\t}\n\treturn upper;\n}\nfunction getInsertionAncestor(matcher) {\n\tlet ancestor = matcher;\n\twhile (ancestor = ancestor.parent) if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) return ancestor;\n}\n/**\n* Checks if a matcher can be reachable. This means if it's possible to reach it as a route. For example, routes without\n* a component, or name, or redirect, are just used to group other routes.\n* @param matcher\n* @param matcher.record record of the matcher\n* @returns\n*/\nfunction isMatchable({ record }) {\n\treturn !!(record.name || record.components && Object.keys(record.components).length || record.redirect);\n}\n\n//#endregion\n//#region src/RouterLink.ts\n/**\n* Returns the internal behavior of a {@link RouterLink} without the rendering part.\n*\n* @param props - a `to` location and an optional `replace` flag\n*/\nfunction useLink(props) {\n\tconst router = inject(routerKey);\n\tconst currentRoute = inject(routeLocationKey);\n\tlet hasPrevious = false;\n\tlet previousTo = null;\n\tconst route = computed(() => {\n\t\tconst to = unref(props.to);\n\t\tif (process.env.NODE_ENV !== \"production\" && (!hasPrevious || to !== previousTo)) {\n\t\t\tif (!isRouteLocation(to)) if (hasPrevious) warn$1(`Invalid value for prop \"to\" in useLink()\\n- to:`, to, `\\n- previous to:`, previousTo, `\\n- props:`, props);\n\t\t\telse warn$1(`Invalid value for prop \"to\" in useLink()\\n- to:`, to, `\\n- props:`, props);\n\t\t\tpreviousTo = to;\n\t\t\thasPrevious = true;\n\t\t}\n\t\treturn router.resolve(to);\n\t});\n\tconst activeRecordIndex = computed(() => {\n\t\tconst { matched } = route.value;\n\t\tconst { length } = matched;\n\t\tconst routeMatched = matched[length - 1];\n\t\tconst currentMatched = currentRoute.matched;\n\t\tif (!routeMatched || !currentMatched.length) return -1;\n\t\tconst index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n\t\tif (index > -1) return index;\n\t\tconst parentRecordPath = getOriginalPath(matched[length - 2]);\n\t\treturn length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;\n\t});\n\tconst isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n\tconst isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n\tfunction navigate(e = {}) {\n\t\tif (guardEvent(e)) {\n\t\t\tconst p = router[unref(props.replace) ? \"replace\" : \"push\"](unref(props.to)).catch(noop);\n\t\t\tif (props.viewTransition && typeof document !== \"undefined\" && \"startViewTransition\" in document) document.startViewTransition(() => p);\n\t\t\treturn p;\n\t\t}\n\t\treturn Promise.resolve();\n\t}\n\tif ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n\t\tconst instance = getCurrentInstance();\n\t\tif (instance) {\n\t\t\tconst linkContextDevtools = {\n\t\t\t\troute: route.value,\n\t\t\t\tisActive: isActive.value,\n\t\t\t\tisExactActive: isExactActive.value,\n\t\t\t\terror: null\n\t\t\t};\n\t\t\tinstance.__vrl_devtools = instance.__vrl_devtools || [];\n\t\t\tinstance.__vrl_devtools.push(linkContextDevtools);\n\t\t\twatchEffect(() => {\n\t\t\t\tlinkContextDevtools.route = route.value;\n\t\t\t\tlinkContextDevtools.isActive = isActive.value;\n\t\t\t\tlinkContextDevtools.isExactActive = isExactActive.value;\n\t\t\t\tlinkContextDevtools.error = isRouteLocation(unref(props.to)) ? null : \"Invalid \\\"to\\\" value\";\n\t\t\t}, { flush: \"post\" });\n\t\t}\n\t}\n\t/**\n\t* NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this\n\t*/\n\treturn {\n\t\troute,\n\t\thref: computed(() => route.value.href),\n\t\tisActive,\n\t\tisExactActive,\n\t\tnavigate\n\t};\n}\nfunction preferSingleVNode(vnodes) {\n\treturn vnodes.length === 1 ? vnodes[0] : vnodes;\n}\nconst RouterLinkImpl = /* @__PURE__ */ defineComponent({\n\tname: \"RouterLink\",\n\tcompatConfig: { MODE: 3 },\n\tprops: {\n\t\tto: {\n\t\t\ttype: [String, Object],\n\t\t\trequired: true\n\t\t},\n\t\treplace: Boolean,\n\t\tactiveClass: String,\n\t\texactActiveClass: String,\n\t\tcustom: Boolean,\n\t\tariaCurrentValue: {\n\t\t\ttype: String,\n\t\t\tdefault: \"page\"\n\t\t},\n\t\tviewTransition: Boolean\n\t},\n\tuseLink,\n\tsetup(props, { slots }) {\n\t\tconst link = reactive(useLink(props));\n\t\tconst { options } = inject(routerKey);\n\t\tconst elClass = computed(() => ({\n\t\t\t[getLinkClass(props.activeClass, options.linkActiveClass, \"router-link-active\")]: link.isActive,\n\t\t\t[getLinkClass(props.exactActiveClass, options.linkExactActiveClass, \"router-link-exact-active\")]: link.isExactActive\n\t\t}));\n\t\treturn () => {\n\t\t\tconst children = slots.default && preferSingleVNode(slots.default(link));\n\t\t\treturn props.custom ? children : h(\"a\", {\n\t\t\t\t\"aria-current\": link.isExactActive ? props.ariaCurrentValue : null,\n\t\t\t\thref: link.href,\n\t\t\t\tonClick: link.navigate,\n\t\t\t\tclass: elClass.value\n\t\t\t}, children);\n\t\t};\n\t}\n});\n/**\n* Component to render a link that triggers a navigation on click.\n*/\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n\tif (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;\n\tif (e.defaultPrevented) return;\n\tif (e.button !== void 0 && e.button !== 0) return;\n\tif (e.currentTarget && e.currentTarget.getAttribute) {\n\t\tconst target = e.currentTarget.getAttribute(\"target\");\n\t\tif (/\\b_blank\\b/i.test(target)) return;\n\t}\n\tif (e.preventDefault) e.preventDefault();\n\treturn true;\n}\nfunction includesParams(outer, inner) {\n\tfor (const key in inner) {\n\t\tconst innerValue = inner[key];\n\t\tconst outerValue = outer[key];\n\t\tif (typeof innerValue === \"string\") {\n\t\t\tif (innerValue !== outerValue) return false;\n\t\t} else if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value.valueOf() !== outerValue[i].valueOf())) return false;\n\t}\n\treturn true;\n}\n/**\n* Get the original path value of a record by following its aliasOf\n* @param record\n*/\nfunction getOriginalPath(record) {\n\treturn record ? record.aliasOf ? record.aliasOf.path : record.path : \"\";\n}\n/**\n* Utility class to get the active class based on defaults.\n* @param propClass\n* @param globalClass\n* @param defaultClass\n*/\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\n\n//#endregion\n//#region src/RouterView.ts\nconst RouterViewImpl = /* @__PURE__ */ defineComponent({\n\tname: \"RouterView\",\n\tinheritAttrs: false,\n\tprops: {\n\t\tname: {\n\t\t\ttype: String,\n\t\t\tdefault: \"default\"\n\t\t},\n\t\troute: Object\n\t},\n\tcompatConfig: { MODE: 3 },\n\tsetup(props, { attrs, slots }) {\n\t\tprocess.env.NODE_ENV !== \"production\" && warnDeprecatedUsage();\n\t\tconst injectedRoute = inject(routerViewLocationKey);\n\t\tconst routeToDisplay = computed(() => props.route || injectedRoute.value);\n\t\tconst injectedDepth = inject(viewDepthKey, 0);\n\t\tconst depth = computed(() => {\n\t\t\tlet initialDepth = unref(injectedDepth);\n\t\t\tconst { matched } = routeToDisplay.value;\n\t\t\tlet matchedRoute;\n\t\t\twhile ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) initialDepth++;\n\t\t\treturn initialDepth;\n\t\t});\n\t\tconst matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);\n\t\tprovide(viewDepthKey, computed(() => depth.value + 1));\n\t\tprovide(matchedRouteKey, matchedRouteRef);\n\t\tprovide(routerViewLocationKey, routeToDisplay);\n\t\tconst viewRef = ref();\n\t\twatch(() => [\n\t\t\tviewRef.value,\n\t\t\tmatchedRouteRef.value,\n\t\t\tprops.name\n\t\t], ([instance, to, name], [oldInstance, from, oldName]) => {\n\t\t\tif (to) {\n\t\t\t\tto.instances[name] = instance;\n\t\t\t\tif (from && from !== to && instance && instance === oldInstance) {\n\t\t\t\t\tif (!to.leaveGuards.size) to.leaveGuards = from.leaveGuards;\n\t\t\t\t\tif (!to.updateGuards.size) to.updateGuards = from.updateGuards;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));\n\t\t}, { flush: \"post\" });\n\t\treturn () => {\n\t\t\tconst route = routeToDisplay.value;\n\t\t\tconst currentName = props.name;\n\t\t\tconst matchedRoute = matchedRouteRef.value;\n\t\t\tconst ViewComponent = matchedRoute && matchedRoute.components[currentName];\n\t\t\tif (!ViewComponent) return normalizeSlot(slots.default, {\n\t\t\t\tComponent: ViewComponent,\n\t\t\t\troute\n\t\t\t});\n\t\t\tconst routePropsOption = matchedRoute.props[currentName];\n\t\t\tconst routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === \"function\" ? routePropsOption(route) : routePropsOption : null;\n\t\t\tconst onVnodeUnmounted = (vnode) => {\n\t\t\t\tif (vnode.component.isUnmounted) matchedRoute.instances[currentName] = null;\n\t\t\t};\n\t\t\tconst component = h(ViewComponent, assign({}, routeProps, attrs, {\n\t\t\t\tonVnodeUnmounted,\n\t\t\t\tref: viewRef\n\t\t\t}));\n\t\t\tif ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser && component.ref) {\n\t\t\t\tconst info = {\n\t\t\t\t\tdepth: depth.value,\n\t\t\t\t\tname: matchedRoute.name,\n\t\t\t\t\tpath: matchedRoute.path,\n\t\t\t\t\tmeta: matchedRoute.meta\n\t\t\t\t};\n\t\t\t\t(isArray(component.ref) ? component.ref.map((r) => r.i) : [component.ref.i]).forEach((instance) => {\n\t\t\t\t\tinstance.__vrv_devtools = info;\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn normalizeSlot(slots.default, {\n\t\t\t\tComponent: component,\n\t\t\t\troute\n\t\t\t}) || component;\n\t\t};\n\t}\n});\nfunction normalizeSlot(slot, data) {\n\tif (!slot) return null;\n\tconst slotContent = slot(data);\n\treturn slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n/**\n* Component to display the current route the user is at.\n*/\nconst RouterView = RouterViewImpl;\nfunction warnDeprecatedUsage() {\n\tconst instance = getCurrentInstance();\n\tconst parentName = instance.parent && instance.parent.type.name;\n\tconst parentSubTreeType = instance.parent && instance.parent.subTree && instance.parent.subTree.type;\n\tif (parentName && (parentName === \"KeepAlive\" || parentName.includes(\"Transition\")) && typeof parentSubTreeType === \"object\" && parentSubTreeType.name === \"RouterView\") {\n\t\tconst comp = parentName === \"KeepAlive\" ? \"keep-alive\" : \"transition\";\n\t\twarn$1(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\nUse slot props instead:\n\n<router-view v-slot=\"{ Component }\">\n  <${comp}>\\n    <component :is=\"Component\" />\\n  </${comp}>\\n</router-view>`);\n\t}\n}\n\n//#endregion\n//#region src/router.ts\n/**\n* Creates a Router instance that can be used by a Vue app.\n*\n* @param options - {@link RouterOptions}\n*/\nfunction createRouter(options) {\n\tconst matcher = createRouterMatcher(options.routes, options);\n\tconst parseQuery$1 = options.parseQuery || parseQuery;\n\tconst stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n\tconst routerHistory = options.history;\n\tif (process.env.NODE_ENV !== \"production\" && !routerHistory) throw new Error(\"Provide the \\\"history\\\" option when calling \\\"createRouter()\\\": https://router.vuejs.org/api/interfaces/RouterOptions.html#history\");\n\tconst beforeGuards = useCallbacks();\n\tconst beforeResolveGuards = useCallbacks();\n\tconst afterGuards = useCallbacks();\n\tconst currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n\tlet pendingLocation = START_LOCATION_NORMALIZED;\n\tif (isBrowser && options.scrollBehavior && \"scrollRestoration\" in history) history.scrollRestoration = \"manual\";\n\tconst normalizeParams = applyToParams.bind(null, (paramValue) => \"\" + paramValue);\n\tconst encodeParams = applyToParams.bind(null, encodeParam);\n\tconst decodeParams = applyToParams.bind(null, decode);\n\tfunction addRoute(parentOrRoute, route) {\n\t\tlet parent;\n\t\tlet record;\n\t\tif (isRouteName(parentOrRoute)) {\n\t\t\tparent = matcher.getRecordMatcher(parentOrRoute);\n\t\t\tif (process.env.NODE_ENV !== \"production\" && !parent) warn$1(`Parent route \"${String(parentOrRoute)}\" not found when adding child route`, route);\n\t\t\trecord = route;\n\t\t} else record = parentOrRoute;\n\t\treturn matcher.addRoute(record, parent);\n\t}\n\tfunction removeRoute(name) {\n\t\tconst recordMatcher = matcher.getRecordMatcher(name);\n\t\tif (recordMatcher) matcher.removeRoute(recordMatcher);\n\t\telse if (process.env.NODE_ENV !== \"production\") warn$1(`Cannot remove non-existent route \"${String(name)}\"`);\n\t}\n\tfunction getRoutes() {\n\t\treturn matcher.getRoutes().map((routeMatcher) => routeMatcher.record);\n\t}\n\tfunction hasRoute(name) {\n\t\treturn !!matcher.getRecordMatcher(name);\n\t}\n\tfunction resolve(rawLocation, currentLocation) {\n\t\tcurrentLocation = assign({}, currentLocation || currentRoute.value);\n\t\tif (typeof rawLocation === \"string\") {\n\t\t\tconst locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n\t\t\tconst matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\n\t\t\tconst href = routerHistory.createHref(locationNormalized.fullPath);\n\t\t\tif (process.env.NODE_ENV !== \"production\") {\n\t\t\t\tif (href.startsWith(\"//\")) warn$1(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n\t\t\t\telse if (!matchedRoute.matched.length) warn$1(`No match found for location with path \"${rawLocation}\"`);\n\t\t\t}\n\t\t\treturn assign(locationNormalized, matchedRoute, {\n\t\t\t\tparams: decodeParams(matchedRoute.params),\n\t\t\t\thash: decode(locationNormalized.hash),\n\t\t\t\tredirectedFrom: void 0,\n\t\t\t\thref\n\t\t\t});\n\t\t}\n\t\tif (process.env.NODE_ENV !== \"production\" && !isRouteLocation(rawLocation)) {\n\t\t\twarn$1(`router.resolve() was passed an invalid location. This will fail in production.\\n- Location:`, rawLocation);\n\t\t\treturn resolve({});\n\t\t}\n\t\tlet matcherLocation;\n\t\tif (rawLocation.path != null) {\n\t\t\tif (process.env.NODE_ENV !== \"production\" && \"params\" in rawLocation && !(\"name\" in rawLocation) && Object.keys(rawLocation.params).length) warn$1(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n\t\t\tmatcherLocation = assign({}, rawLocation, { path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path });\n\t\t} else {\n\t\t\tconst targetParams = assign({}, rawLocation.params);\n\t\t\tfor (const key in targetParams) if (targetParams[key] == null) delete targetParams[key];\n\t\t\tmatcherLocation = assign({}, rawLocation, { params: encodeParams(targetParams) });\n\t\t\tcurrentLocation.params = encodeParams(currentLocation.params);\n\t\t}\n\t\tconst matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n\t\tconst hash = rawLocation.hash || \"\";\n\t\tif (process.env.NODE_ENV !== \"production\" && hash && !hash.startsWith(\"#\")) warn$1(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n\t\tmatchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n\t\tconst fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n\t\t\thash: encodeHash(hash),\n\t\t\tpath: matchedRoute.path\n\t\t}));\n\t\tconst href = routerHistory.createHref(fullPath);\n\t\tif (process.env.NODE_ENV !== \"production\") {\n\t\t\tif (href.startsWith(\"//\")) warn$1(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n\t\t\telse if (!matchedRoute.matched.length) warn$1(`No match found for location with path \"${rawLocation.path != null ? rawLocation.path : rawLocation}\"`);\n\t\t}\n\t\treturn assign({\n\t\t\tfullPath,\n\t\t\thash,\n\t\t\tquery: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}\n\t\t}, matchedRoute, {\n\t\t\tredirectedFrom: void 0,\n\t\t\thref\n\t\t});\n\t}\n\tfunction locationAsObject(to) {\n\t\treturn typeof to === \"string\" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n\t}\n\tfunction checkCanceledNavigation(to, from) {\n\t\tif (pendingLocation !== to) return createRouterError(ErrorTypes.NAVIGATION_CANCELLED, {\n\t\t\tfrom,\n\t\t\tto\n\t\t});\n\t}\n\tfunction push(to) {\n\t\treturn pushWithRedirect(to);\n\t}\n\tfunction replace(to) {\n\t\treturn push(assign(locationAsObject(to), { replace: true }));\n\t}\n\tfunction handleRedirectRecord(to, from) {\n\t\tconst lastMatched = to.matched[to.matched.length - 1];\n\t\tif (lastMatched && lastMatched.redirect) {\n\t\t\tconst { redirect } = lastMatched;\n\t\t\tlet newTargetLocation = typeof redirect === \"function\" ? redirect(to, from) : redirect;\n\t\t\tif (typeof newTargetLocation === \"string\") {\n\t\t\t\tnewTargetLocation = newTargetLocation.includes(\"?\") || newTargetLocation.includes(\"#\") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };\n\t\t\t\tnewTargetLocation.params = {};\n\t\t\t}\n\t\t\tif (process.env.NODE_ENV !== \"production\" && newTargetLocation.path == null && !(\"name\" in newTargetLocation)) {\n\t\t\t\twarn$1(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n\t\t\t\tthrow new Error(\"Invalid redirect\");\n\t\t\t}\n\t\t\treturn assign({\n\t\t\t\tquery: to.query,\n\t\t\t\thash: to.hash,\n\t\t\t\tparams: newTargetLocation.path != null ? {} : to.params\n\t\t\t}, newTargetLocation);\n\t\t}\n\t}\n\tfunction pushWithRedirect(to, redirectedFrom) {\n\t\tconst targetLocation = pendingLocation = resolve(to);\n\t\tconst from = currentRoute.value;\n\t\tconst data = to.state;\n\t\tconst force = to.force;\n\t\tconst replace = to.replace === true;\n\t\tconst shouldRedirect = handleRedirectRecord(targetLocation, from);\n\t\tif (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n\t\t\tstate: typeof shouldRedirect === \"object\" ? assign({}, data, shouldRedirect.state) : data,\n\t\t\tforce,\n\t\t\treplace\n\t\t}), redirectedFrom || targetLocation);\n\t\tconst toLocation = targetLocation;\n\t\ttoLocation.redirectedFrom = redirectedFrom;\n\t\tlet failure;\n\t\tif (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n\t\t\tfailure = createRouterError(ErrorTypes.NAVIGATION_DUPLICATED, {\n\t\t\t\tto: toLocation,\n\t\t\t\tfrom\n\t\t\t});\n\t\t\thandleScroll(from, from, true, false);\n\t\t}\n\t\treturn (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure) => {\n\t\t\tif (failure) {\n\t\t\t\tif (isNavigationFailure(failure, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {\n\t\t\t\t\tif (process.env.NODE_ENV !== \"production\" && isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 30) {\n\t\t\t\t\t\twarn$1(`Detected a possibly infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow.\\n Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`);\n\t\t\t\t\t\treturn Promise.reject(/* @__PURE__ */ new Error(\"Infinite redirect in navigation guard\"));\n\t\t\t\t\t}\n\t\t\t\t\treturn pushWithRedirect(assign({ replace }, locationAsObject(failure.to), {\n\t\t\t\t\t\tstate: typeof failure.to === \"object\" ? assign({}, data, failure.to.state) : data,\n\t\t\t\t\t\tforce\n\t\t\t\t\t}), redirectedFrom || toLocation);\n\t\t\t\t}\n\t\t\t} else failure = finalizeNavigation(toLocation, from, true, replace, data);\n\t\t\ttriggerAfterEach(toLocation, from, failure);\n\t\t\treturn failure;\n\t\t});\n\t}\n\t/**\n\t* Helper to reject and skip all navigation guards if a new navigation happened\n\t* @param to\n\t* @param from\n\t*/\n\tfunction checkCanceledNavigationAndReject(to, from) {\n\t\tconst error = checkCanceledNavigation(to, from);\n\t\treturn error ? Promise.reject(error) : Promise.resolve();\n\t}\n\tfunction runWithContext(fn) {\n\t\tconst app = installedApps.values().next().value;\n\t\treturn app && typeof app.runWithContext === \"function\" ? app.runWithContext(fn) : fn();\n\t}\n\tfunction navigate(to, from) {\n\t\tlet guards;\n\t\tconst [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n\t\tguards = extractComponentsGuards(leavingRecords.reverse(), \"beforeRouteLeave\", to, from);\n\t\tfor (const record of leavingRecords) record.leaveGuards.forEach((guard) => {\n\t\t\tguards.push(guardToPromiseFn(guard, to, from));\n\t\t});\n\t\tconst canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n\t\tguards.push(canceledNavigationCheck);\n\t\treturn runGuardQueue(guards).then(() => {\n\t\t\tguards = [];\n\t\t\tfor (const guard of beforeGuards.list()) guards.push(guardToPromiseFn(guard, to, from));\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).then(() => {\n\t\t\tguards = extractComponentsGuards(updatingRecords, \"beforeRouteUpdate\", to, from);\n\t\t\tfor (const record of updatingRecords) record.updateGuards.forEach((guard) => {\n\t\t\t\tguards.push(guardToPromiseFn(guard, to, from));\n\t\t\t});\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).then(() => {\n\t\t\tguards = [];\n\t\t\tfor (const record of enteringRecords) if (record.beforeEnter) if (isArray(record.beforeEnter)) for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));\n\t\t\telse guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).then(() => {\n\t\t\tto.matched.forEach((record) => record.enterCallbacks = {});\n\t\t\tguards = extractComponentsGuards(enteringRecords, \"beforeRouteEnter\", to, from, runWithContext);\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).then(() => {\n\t\t\tguards = [];\n\t\t\tfor (const guard of beforeResolveGuards.list()) guards.push(guardToPromiseFn(guard, to, from));\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).catch((err) => isNavigationFailure(err, ErrorTypes.NAVIGATION_CANCELLED) ? err : Promise.reject(err));\n\t}\n\tfunction triggerAfterEach(to, from, failure) {\n\t\tafterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));\n\t}\n\t/**\n\t* - Cleans up any navigation guards\n\t* - Changes the url if necessary\n\t* - Calls the scrollBehavior\n\t*/\n\tfunction finalizeNavigation(toLocation, from, isPush, replace, data) {\n\t\tconst error = checkCanceledNavigation(toLocation, from);\n\t\tif (error) return error;\n\t\tconst isFirstNavigation = from === START_LOCATION_NORMALIZED;\n\t\tconst state = !isBrowser ? {} : history.state;\n\t\tif (isPush) if (replace || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({ scroll: isFirstNavigation && state && state.scroll }, data));\n\t\telse routerHistory.push(toLocation.fullPath, data);\n\t\tcurrentRoute.value = toLocation;\n\t\thandleScroll(toLocation, from, isPush, isFirstNavigation);\n\t\tmarkAsReady();\n\t}\n\tlet removeHistoryListener;\n\tfunction setupListeners() {\n\t\tif (removeHistoryListener) return;\n\t\tremoveHistoryListener = routerHistory.listen((to, _from, info) => {\n\t\t\tif (!router.listening) return;\n\t\t\tconst toLocation = resolve(to);\n\t\t\tconst shouldRedirect = handleRedirectRecord(toLocation, router.currentRoute.value);\n\t\t\tif (shouldRedirect) {\n\t\t\t\tpushWithRedirect(assign(shouldRedirect, {\n\t\t\t\t\treplace: true,\n\t\t\t\t\tforce: true\n\t\t\t\t}), toLocation).catch(noop);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpendingLocation = toLocation;\n\t\t\tconst from = currentRoute.value;\n\t\t\tif (isBrowser) saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n\t\t\tnavigate(toLocation, from).catch((error) => {\n\t\t\t\tif (isNavigationFailure(error, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_CANCELLED)) return error;\n\t\t\t\tif (isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {\n\t\t\t\t\tpushWithRedirect(assign(locationAsObject(error.to), { force: true }), toLocation).then((failure) => {\n\t\t\t\t\t\tif (isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED) && !info.delta && info.type === NavigationType.pop) routerHistory.go(-1, false);\n\t\t\t\t\t}).catch(noop);\n\t\t\t\t\treturn Promise.reject();\n\t\t\t\t}\n\t\t\t\tif (info.delta) routerHistory.go(-info.delta, false);\n\t\t\t\treturn triggerError(error, toLocation, from);\n\t\t\t}).then((failure) => {\n\t\t\t\tfailure = failure || finalizeNavigation(toLocation, from, false);\n\t\t\t\tif (failure) {\n\t\t\t\t\tif (info.delta && !isNavigationFailure(failure, ErrorTypes.NAVIGATION_CANCELLED)) routerHistory.go(-info.delta, false);\n\t\t\t\t\telse if (info.type === NavigationType.pop && isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED)) routerHistory.go(-1, false);\n\t\t\t\t}\n\t\t\t\ttriggerAfterEach(toLocation, from, failure);\n\t\t\t}).catch(noop);\n\t\t});\n\t}\n\tlet readyHandlers = useCallbacks();\n\tlet errorListeners = useCallbacks();\n\tlet ready;\n\t/**\n\t* Trigger errorListeners added via onError and throws the error as well\n\t*\n\t* @param error - error to throw\n\t* @param to - location we were navigating to when the error happened\n\t* @param from - location we were navigating from when the error happened\n\t* @returns the error as a rejected promise\n\t*/\n\tfunction triggerError(error, to, from) {\n\t\tmarkAsReady(error);\n\t\tconst list = errorListeners.list();\n\t\tif (list.length) list.forEach((handler) => handler(error, to, from));\n\t\telse {\n\t\t\tif (process.env.NODE_ENV !== \"production\") warn$1(\"uncaught error during route navigation:\");\n\t\t\tconsole.error(error);\n\t\t}\n\t\treturn Promise.reject(error);\n\t}\n\tfunction isReady() {\n\t\tif (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treadyHandlers.add([resolve, reject]);\n\t\t});\n\t}\n\tfunction markAsReady(err) {\n\t\tif (!ready) {\n\t\t\tready = !err;\n\t\t\tsetupListeners();\n\t\t\treadyHandlers.list().forEach(([resolve, reject]) => err ? reject(err) : resolve());\n\t\t\treadyHandlers.reset();\n\t\t}\n\t\treturn err;\n\t}\n\tfunction handleScroll(to, from, isPush, isFirstNavigation) {\n\t\tconst { scrollBehavior } = options;\n\t\tif (!isBrowser || !scrollBehavior) return Promise.resolve();\n\t\tconst scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n\t\treturn nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));\n\t}\n\tconst go = (delta) => routerHistory.go(delta);\n\tlet started;\n\tconst installedApps = /* @__PURE__ */ new Set();\n\tconst router = {\n\t\tcurrentRoute,\n\t\tlistening: true,\n\t\taddRoute,\n\t\tremoveRoute,\n\t\tclearRoutes: matcher.clearRoutes,\n\t\thasRoute,\n\t\tgetRoutes,\n\t\tresolve,\n\t\toptions,\n\t\tpush,\n\t\treplace,\n\t\tgo,\n\t\tback: () => go(-1),\n\t\tforward: () => go(1),\n\t\tbeforeEach: beforeGuards.add,\n\t\tbeforeResolve: beforeResolveGuards.add,\n\t\tafterEach: afterGuards.add,\n\t\tonError: errorListeners.add,\n\t\tisReady,\n\t\tinstall(app) {\n\t\t\tapp.component(\"RouterLink\", RouterLink);\n\t\t\tapp.component(\"RouterView\", RouterView);\n\t\t\tapp.config.globalProperties.$router = router;\n\t\t\tObject.defineProperty(app.config.globalProperties, \"$route\", {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: () => unref(currentRoute)\n\t\t\t});\n\t\t\tif (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n\t\t\t\tstarted = true;\n\t\t\t\tpush(routerHistory.location).catch((err) => {\n\t\t\t\t\tif (process.env.NODE_ENV !== \"production\") warn$1(\"Unexpected error when starting the router:\", err);\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst reactiveRoute = {};\n\t\t\tfor (const key in START_LOCATION_NORMALIZED) Object.defineProperty(reactiveRoute, key, {\n\t\t\t\tget: () => currentRoute.value[key],\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t\tapp.provide(routerKey, router);\n\t\t\tapp.provide(routeLocationKey, shallowReactive(reactiveRoute));\n\t\t\tapp.provide(routerViewLocationKey, currentRoute);\n\t\t\tconst unmountApp = app.unmount;\n\t\t\tinstalledApps.add(app);\n\t\t\tapp.unmount = function() {\n\t\t\t\tinstalledApps.delete(app);\n\t\t\t\tif (installedApps.size < 1) {\n\t\t\t\t\tpendingLocation = START_LOCATION_NORMALIZED;\n\t\t\t\t\tremoveHistoryListener && removeHistoryListener();\n\t\t\t\t\tremoveHistoryListener = null;\n\t\t\t\t\tcurrentRoute.value = START_LOCATION_NORMALIZED;\n\t\t\t\t\tstarted = false;\n\t\t\t\t\tready = false;\n\t\t\t\t}\n\t\t\t\tunmountApp();\n\t\t\t};\n\t\t\tif ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser && true) addDevtools(app, router, matcher);\n\t\t}\n\t};\n\tfunction runGuardQueue(guards) {\n\t\treturn guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());\n\t}\n\treturn router;\n}\n\n//#endregion\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, loadRouteLocation, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}